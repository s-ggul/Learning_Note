## 스레드와 태스크
--------

<br />

- `프로세스(Process)` : 실행파일이 실행되어 메모리에 적재된 인스턴스
- 프로세스는 하나 이상의 `스레드(Thread)`로 구성된다.
- 스레드는 운영체제가 CPU를 할당하는 기본단위이며, 프로세스가 밧줄이라면, 스레드는 밧줄을 이루고 있는 실이라고 할 수 있다.

#### 멀티 스레드(Multi-Thread)를 이용했을때의 장단점.

<br />

##### 장점

1. 사용자 대화형 프로그램에서(콘솔 프로그램과 GUI프로그램 모두) 멀티스레드를 이용하면 응답성을 높일 수 있다는 점을 꼽을 수 있다.
    - 예를 들어 우리가 만든 프로그램을 파일을 복사하는데, 복사할 피일이 너무 커서 소요시간이 30분정도 걸린다고 가정해보자. 이 때 프로그램을 단일 스레드로 만든다면 프로그램이 파일을 복사하는 동안 사용자가 취소 명령을 내리고 싶어도 프로그램이 사용자에게 반응하지 않으므로, 복사를 취소할 수가 없다. 작업관리자를 이용해 강제로 프로세스를 종료시키지 않는 한.. 이 프로그램에 사용자와의 대화를 위한 스레드를 하나 더 추가한다면 파일복사를 하면서도 사용자로부터 명령을 받을 수 있다. 
  
  <br />

2. 멀티 프로세스 방식에 비해 멀티 스레드 방식이 자원공유가 더 쉽다는 점이 있다. 
      - 멀티 프로세스는 GUI가 없는 웹서버같은 서버용 애플리케이션에서 많이 취하는 구조인데, 프로세스끼리 데이터를 교환하려면 소켓이나 공유 메모리 같은 IPC(Inter Process Communication)를 이용해야 한다. 반면 멀티 스레드 방식에서는 그저 스레드끼리 코드 내의 변수를 같이 사용하는 것만으로도 데이터 교환을 할 수 있다. 

<br />

3. 프로세스를 띄우기 위해 메모리와 자원을 할당하는 작업은 (CPU 사용시간등의) 비용이 비싼데, 스레드를 띄울때는 이미 프로세스에 할당된 메모리와 자원을 그대로 사용하므로 메모리와 자원을 할당하는 비용을 지불하지 않아도 된다.

<br />

##### 단점

1. 구현하기가 매우 까다롭다.
2. 테스트하기가 쉽지 않다.
3. 멀티 프로세스 기반의 소프트웨어는 여러 개의 자식프로세스 중 하나에 문제가 생기면 영향이 확산되지 않지만, 멀티 스레드 기반의 소프트웨어에서는 자식 스레드 중 하나에 문제가 생기면 전체에 영향을 미친다.
4. 멀티스레드에서 스레드를 너무 많이 사용하면 오히려 성능이 저하되는 문제가 생길 수 있다.
    - 스레드가 CPU를 사용하기 위해 작업 간 전환(Context Switching)을 해야하는데, 이 작업간 전환이 많은 비용을 소모한다. 많은 스레드가 너무 자주 작업 간 전환을 수행하다 보면 애플리케이션이 실제로 일을 하는 시간에 비해 작업 간 전환에 사용하는 시간이 커지기 때문에 성능이 저하된다.

#### 스레드 시작하기

```csharp
1. Thread의 인스턴스를 생성한다. 이 때 생성자의 매개변수로 스레드가 실행할 메소드를 매개변수로 넘긴다.
2. Thread.Start() 메소드를 호출하여 스레드를 시작한다.
3. Thread.Join() 메소드를 호출하여 스레드가 끝날 때까지 기다린다.
```

```csharp
using System;
using System.Threading;

namespace ThreadEx
{

    class MainApp
    {
        static void DoSomething() // 스레드가 실행할 메소드
        {
            for(int i = 0; i < 5; i++)
            {
                Console.WriteLine($"DoSomething : {i}");
            }
            Thread.Sleep(10); 
            //sleep 메소드는 다른쓰레드도 CPU를 사용할 수 있도록, CPU점유를 내려놓는다. 매개변수는 밀리초 단위이다.
        }

        static void Main(string[] args)
        {
            Thread t1 = new Thread(new ThreadStart(DoSomething)); // Thread의 인스턴스 생성

            Console.WriteLine("Start Threading...");
            t1.Start(); // 스레드 시작

            for(int i = 0; i < 5; i++)
            {
                Console.WriteLine($"Main : {i}");
                Thread.Sleep(10);   
            }

            Console.WriteLine("Wating until thread stops...");
            t1.Join(); // 스레드의 종료 대기

            Console.WriteLine("Finished");
        }
    }
} 
```

```java
Output

Start Threading...
Main : 0
DoSomething : 0
DoSomething : 1
DoSomething : 2
DoSomething : 3
DoSomething : 4
Main : 1
Main : 2
Main : 3
Main : 4
Wating until thread stops...
Finished
```

<br />

#### 스레드 임의로 종료시키기.

```csharp

Thread t1 = new Thread(new ThreadStart(DoSomething)); // Thread의 인스턴스 생성

t1.Start();

t1.Abort(); // => 스레드 취소 종료

t1.Join();

```

- `Abort()`메소드는 선언 후 join메소드를 이용해 기다렸다가 합쳐줘야함. Abort()자체적으로 처리 시간을 조금은 염두해야하기에..

- 프로그래머들 사이에서 Abort 메소드의 사용은 `금기시` 되어있기에 `가급적 사용하지 않는것을 추천`한다. => 잘못하면 공유자원이 잠긴채로 쓰레드가 종료되어 다른 스레드에서도 접근하지 못할 수 있음.

``` csharp
using System;
using System.Threading;

namespace ThreadEx
{
    class SideTask
    {
        int count;

        public SideTask(int count)
        {
            this.count = count;
        }

        public void KeepAlive()
        {
            try
            {
                while(count > 0)
                {
                    Console.WriteLine($"{count--} left");
                    Thread.Sleep(10);
                }
                Console.WriteLine("count : 0");
            }
            catch(ThreadAbortException e)
            {
                Console.WriteLine(e);
                Thread.ResetAbort();
            }
            finally
            {
                Console.WriteLine("Clearing resource...");
            }
        }
    }
    class MainApp
    {
        static void Main(string[] args)
        {
            SideTask st = new SideTask(100);
            Thread t1 = new Thread(new ThreadStart(st.KeepAlive));
            t1.IsBackground = false;

            Console.WriteLine("Starting thread ... ");
            t1.Start();

            Thread.Sleep(100);

            Console.WriteLine("Aborting thread ... ");
            t1.Abort();

            Console.WriteLine("Waiting until thread stops ... ");
            t1.Join();

            Console.WriteLine("Finished");
        }
    }
} 
```
```java
Output

Starting thread ...
100 left
99 left
98 left
97 left
96 left
95 left
94 left
Aborting thread ...
93 left
Unhandled exception. 92 left
System.PlatformNotSupportedException: Thread abort is not supported on this platform.
   at System.Threading.Thread.Abort()
   at ThreadEx.MainApp.Main(String[] args) in C:\Users\shkim\source\repos\ClassEx\practice1\Program.cs:line 51
91 left
90 left
89 left
88 left
87 left
86 left
85 left
```

- 현재 사용하고 있는 플랫폼에서 지원하지 않는듯함.

```csharp
프로그래머들 사이에서 Abort 메소드의 사용은 `금기시` 되어있기에 `가급적 사용하지 않는것을 추천`한다. 
=> 잘못하면 공유자원이 잠긴채로 쓰레드가 종료되어 다른 스레드에서도 접근하지 못할 수 있음.
```

- 위와 같은 이유 때문에 지원하지 않는 것일지도 모르겠음..

<br />

#### 스레드의 일생과 상태 변화 

|상태|설명|
|:---:|---|
|Unstarted|스레드 객체를 생성한 후 Thread.Start() 메소드가 호출되기 전의 상태|
|Running|스레드가 시작하여 동작중인 상태를 나타냅니다. Unstarted 상태의 스레드를 Thread.Start()메소드를 통해 이 상태로 만들 수 있음|
|Suspended|스레드의 일시 중단 상태를 나타낸다. 스레드를 Thread.Suspend() 메소드를 통해 이 상태로 만들 수 있으며, Suspended상태인 스레드는 Thread.Resume() 메소드를 통해 다시 Running 상태로 만들 수 있음.|
|WaitSleepJoin|스레드가 블록(Block)된 상태를 나타냄. 상태이름이 block이 아닌 WaitSleepJoin인 이유는 스레드에 대해 Monitor.Enter(), Thread.Sleep() 또는 Thread.Join() 메소드를 호출하면 이 상태가 되기 때문.|
|Aborted|스레드가 취소된 상태를 나타낸다. Thread.Abort() 메소드를 호출하면 이 상태가 됨. Aborted 상태가 된 스레드는 다시 Stopped 상태로 전환되어 완전히 중지됨.|
|Stopped|중지된 스레드의 상태를 나타냄. Abort() 메소드를 호출하거나 스레드가 실행중인 메소드가 종료되면 이 상태가 됨.|
|Background|스레드가 백그라운드로 동작하고 있음을 나타냄. Foreground 스레드는 하나라도 살아있는한 프로세스가 죽지 않지만, 백그라운드 프로세스는 스레드가 하나가 아니라 10개가 살아있어도 프로세스가 죽고 사는 것에는 영향을 미치지 않음. 하지만 프로세스가 죽으면 백그라운드 스레드들도 모두 죽음. Thread.IsBackground 속성에 true값을 입력함으로써 스레드를 이상태로 바꿀 수 있음.|

- 이들 ThreadState 열거형의 멤버들은 Flags 어트리뷰트를 가지고 있다. 
- Flags 속성은 자신이 수식하는 열거형을 비트 필드, 즉 플래그 집합으로 처리할 수 있음을 나타냅니다. 
- 스레드는 두가지 이상의 상태를 가질 수 있다. => 이 두가지 이상의 상태를 표현하기 위해 이 Flags 어트리뷰트가 수식되어있는것.

<br />

##### 비트 필드(Bit Field)

- 스레드는 동시에 두 가지 이상의 상태를 가질 수 있음
- 예를들어 Suspended 상태이면서 WaitSleepJoin 상태를 가질 수도 있고, Background 상태이면서 Stopped 상태일 수도 있음
- ThreadState는 두 가지 이상의 상태를 동시에 표현하기 위해 이 Flags 애트리뷰트가 수식되어 있음
  - `Flags` => 자신이 수식하는 열거형을 비트필드(Bit Field),즉 플래그 집합으로 처리할 수 있음을 나타냄

```csharp
using System;
using System.Threading;

namespace UsingThreadState
{
    class MainApp
    {
        private static void PrintThreadState(ThreadState state)
        {
            Console.WriteLine("{0,-16} : {1}", state,(int) state);
        }

        static void Main(string[] args)
        {
            PrintThreadState(ThreadState.Running);
            PrintThreadState(ThreadState.StopRequested);
            PrintThreadState(ThreadState.SuspendRequested);
            PrintThreadState(ThreadState.Background);
            PrintThreadState(ThreadState.Unstarted);
            PrintThreadState(ThreadState.Stopped);
            PrintThreadState(ThreadState.WaitSleepJoin);
            PrintThreadState(ThreadState.Suspended);
            PrintThreadState(ThreadState.AbortRequested);
            PrintThreadState(ThreadState.Aborted);
            PrintThreadState(ThreadState.Aborted | ThreadState.Stopped);
        }
    }
}
```
```java
Output

Running          : 0
StopRequested    : 1
SuspendRequested : 2
Background       : 4
Unstarted        : 8
Stopped          : 16
WaitSleepJoin    : 32
Suspended        : 64
AbortRequested   : 128
Aborted          : 256
Stopped, Aborted : 272
```

- `ThreadState` 필드를 통해 상태를 확인할 때는 반드시 비트연산을 이용해야 한다.
- `ThreadState` 열거형이 여러 상태를 동시에 나타낼 수 있도록 만들어져 있다.


<br />

##### 비트필드를 이용해 표현한 쓰레드의 상태

|상태|십진수|이진수|
|:----:|:----:|:----:|
|Running|0|000000000|
|StopRequested|1|000000001|
|SuspendedRequested|2|000000010|
|Background|4|000000100|
|Unstarted|8|000001000|
|Stopped|16|000010000|
|WatiSleepJoin|32|000100000|
|Suspended|64|001000000|
|AbortRequested|128|010000000|
|Aborted|256|100000000|

<br />


#### 인터럽트(Interrupt) : 스레드를 임의로 멈추는 또 하나의 방법

- 본래 스레드는 수명을 다해 스스로 종료하는 것이 가장 좋다. 불가피하게 스레드를 강제로 종료시켜야 하는 경우가 있다. 하지만 Thread.Abort() 메소드는 너무 무자비하다. Abort()메소드를 사용할때는 도중에 강제로 중단된다 해도 프로세스 자신이나 시스템에 영향이 없는 작업에 한해 사용하는 것이 좋다. 
- 스레드가 수행 중인 작업이 강제로 중단되는 경우 시스템에 악영향을 미칠 수 있다면 조금 더 부드러운 방법을 택해야 한다.
- `Thread.Interrupt()` 메소드는 스레드가 한참 동작중인 상태(Running 상태)를 피해서 `WaitJoinSleep` 상태에 들어갔을 때 `ThreadInterruptedException` 예외를 던져 스레드를 중지시킨다. => 이러한 특징 때문에 프로그래머는 최소한 코드가 "절대로 중단되면 안되는" 작업을 하고 있을 때는 중단되지 않는다는 보장을 받을 수 있음

```csharp
using System;
using System.Security.Permissions;
using System.Threading;

namespace InterruptingThread
{
    class SideTask
    {
        int count;

        public SideTask(int count)
        {
            this.count = count;
        }

        public void KeepAlive()
        {
            try
            {
                Console.WriteLine("Running thread isn't gonna be interrupted");
                Thread.SpinWait(1000000000);
                // SpinWait() 메소드는 원래 사용할 일이 별로 없다
                // 이 메소드는 Sleep()과 유사하게 스레드를 대기하게 하지만 Sleep()과 달리 스레드가 Running 상태를 유지하게함/.
                 
                while(count > 0)
                {
                    Console.WriteLine("{0} left", count--);

                    Console.WriteLine("Entering into WaitJoinSleep State...");
                    Thread.Sleep(10);
                }
                Console.WriteLine("Count : 0");
            }
            catch(ThreadInterruptedException e)
            {
                Console.WriteLine(e);
            }
            finally
            {
                Console.WriteLine("Clearing resource ...");
            }
        }
    }    
    class MainApp
    {
        static void Main(string[] args)
        {
            SideTask task = new SideTask(100);
            Thread t1 = new Thread(new ThreadStart(task.KeepAlive));
            t1.IsBackground = false;

            Console.WriteLine("Starting thread...");
            t1.Start();

            Thread.Sleep(100);

            Console.WriteLine("Interrupting thread...");
            t1.Interrupt();

            Console.WriteLine("Waiting until thread stops...");
            t1.Join();

            Console.WriteLine("Finished");
        }
    }
}
```
```java
Output

Starting thread...
Running thread isn't gonna be interrupted
Interrupting thread...
Waiting until thread stops...
100 left
Entering into WaitJoinSleep State...
System.Threading.ThreadInterruptedException: Thread was interrupted from a waiting state.
   at System.Threading.Thread.SleepInternal(Int32 millisecondsTimeout)
   at System.Threading.Thread.Sleep(Int32 millisecondsTimeout)
   at InterruptingThread.SideTask.KeepAlive() in C:\Users\shkim\source\repos\ClassEx\practice1\Program.cs:line 30
Clearing resource ...
Finished
```

- `Main`메소드 내 `Interrupt()` 메소드를 호출하는 시점에 스레드가 `Running` 상태를 유지하도록 하기 위해 `SpinWait()` 메소드를 사용
- 해당 `Main`문 내 `interrupt()` 메소드가 호출된 스레드는 `KeepAlive` 메소드 내의 `sleep(10)`에 의해 `WaitSleepJoin` 상태로 들어가고 이때 `인터럽트`가 발생함.

<br />

#### 스레드 간의 동기화

- 애플리케이션을 구성하는 각 스레드는 여러가지 자원을 공유하는 경우가 많다.
    Ex) 파일 핸들이나 네트워크 커넥션, 메모리에 선언한 변수 등
- 각각의 스레드는 본래 다른 스레드가 어떤 자원을 사용하고 있건 상관없이 갑자기 끼어들어 자기 제멋대로 사용해버리는 경우가 다반사이다. 이러한 스레드의 기질을 그대로 두면 소프트웨어들은 모두 엉망이 되어버릴 것임. => 즉, 스레드들이 정연하게 자원을 사용할 수 있도록 질서를 잡아야함
  - 이처럼 스레드들이 순서를 갖추어 자원을 사용하게 하는 것을 일컬어 "`동기화(Synchronization)`" 라고 함. 
  - 이 `동기화` 작업을 제대로 하는 것이야말로 `멀티 스레드 프로그래밍`을 완벽하게 하는 길
- 스레드 동기화에서 가장 중요한 사항은 `자원을 한번에 하나의 스레드가 사용하도록 보장` 하는 것이다. 
  - 이를 달성하기 위해 `.Net` 프레임워크에서는 `lock` 키워드와 `Monitor` 클래스를 제공한다. => 하는 일은 `lock` 키워드와 `Monitor` 클래스 둘 다 비슷하지만 사용하기는 `lock` 키워드가 사용하기 쉽지만 섬세한 동기화 제어 기능은 `Monitor`클래스를 통해 제공한다. => 상황에 맞춰 사용하라는 말이겠쥬~?

<br />

#### lock 키워드로 동기화하기

- `크리티컬 섹션(Critical Section)` : 한번에 한 스레드만 사용할 수 있는 코드영역 => 해당 코드 영역에는 한 번에 한 스레드 혹은 프로세스만 사용가능한 자원이 존재하기에 뮤텍스(Mutex) 또는 세마포어(Semaphore)를 통해 제어해준 것 같은 기억이 있다.
- C# 에서는 `lock`키워드로 감싸주기만 해도 평범한 코드를 크리티컬 섹션으로 바꿀 수 있다.

```csharp
using System;
using System.Threading;

class Counter
{
    public int count = 0;

    public void Increase()
    {
        count += 1;
    }
}

class Program
{
    static void Main(string[] args)
    {
        Counter obj = new Counter();
        Thread t1 = new Thread(new ThreadStart(obj.Increase));
        Thread t2 = new Thread(new ThreadStart(obj.Increase));
        Thread t3 = new Thread(new ThreadStart(obj.Increase));
    
        t1.Start();
        t2.Start();
        t3.Start();

        t1.Join();
        t2.Join();
        t3.Join();
    
        Console.WriteLine(obj.count);
    }
}
```

- 위의 코드는 스레드들이 사이가 좋다면 결과가 3이 나올 것이다
- 하지만 결과값의 범위는 1 ~ 3 이다.
- 언제 어떤 스레드가 `obj`의 `Increase()` 메소드에서 `count` 값을 사용할지 모르기 때문이다
  - `count` => 공유 자원
- 이러한 문제를 해결하기위해서 `count += 1` 코드를 한 스레드가 실행하고 있을 때 다른 스레드에서 접근하지 못하도록하는 장치가 필요함.
- 여기서 `lock`키워드를 사용

```csharp
using System;
using System.Threading;

class Counter
{
    public int count = 0;
    private readonly object thisLock = new object();    

    public void Increase()
    {
        lock ( thisLock )
        { 
        count += 1;
        }
    }
}

class Program
{
    static void Main(string[] args)
    {
        Counter obj = new Counter();
        Thread t1 = new Thread(new ThreadStart(obj.Increase));
        Thread t2 = new Thread(new ThreadStart(obj.Increase));
        Thread t3 = new Thread(new ThreadStart(obj.Increase));
    
        t1.Start();
        t2.Start();
        t3.Start();

        t1.Join();
        t2.Join();
        t3.Join();
    
        Console.WriteLine(obj.count);
    }
}
```
```java
Output

3
```
- 위에서 처럼 `lock` 키워드를 사용하는 것은 간단함
- 여기서의 동작은 각각의 스레드들이 `lock()`의 매개변수로 있는 `thisLock`을 돌려가며 해당 `thisLock`을 가지고 있는 스레드들만이 `크리티컬 섹션`에 접근할 수 있다.
- 이 과정에서 `thisLock`을 얻지 못한 스레드들은 `thisLock`을 달라고 옆에서 징징거리는데 이런 경우 소프트웨어의 성능이 크게 떨어진다. => 따라서 스레드의 동기화를 설계할 때는 크리티컬 섹션을 반드시 필요한 곳에서만 사용하도록 하는 것이 중요하다.

<br />

- 한편 `lock` 키워드의 매개변수로 사용하는 객체는 참조형이면 어느 것이든 사용할 수 있지만 public 키워드 등을 통해 외부 코드에서도 접근할 수 있는 다음 세가지는 절대 사용하지 않기를 권함
    -  문법적으로 문제가 없어 컴파일시에 에러가 나오지 않아 더 골치아픔

|객체| 설명|
|:-----:|:-----:|
|this| 클래스의 인스턴스는 클래스 내부뿐만 아니라 외부에서도 자주 사용된다. 자주 정도가 아니고 거의 항상그렇기에 `lock(this)`는 나쁜 버릇! |
|Type 형식|`typeof` 연산자나 `object` 클래스로부터 물려받은 `GetType()` 메소느는 `Type` 형식의 인스턴스를 반환한다. 즉, 코드의 어느 곳에서나 특정 형식에 대한 `Type` 객체를 얻을 수 있다. `lock(typeof(SomeClass))` 나 `lock(obj.GetType())` 은 피해라 제발! |
|string 형식|절대 `string` 객체로 `lock` 하지 마라 `"abc"` 는 어떤 코드에서든 얻어낼 수 있는 `string 객체`입니다. `lock("abc")` 같은 코드를 쓰는 짓은 피해라! |


<br />

##### lock 키워드로 동기화하기 사용 예제 
```csharp
using System;
using System.Threading;

namespace Synchronize
{
    class Counter
    {
        const int LOOP_COUNT = 1000;

        readonly object thisLock;

        private int count;
        public int Count
        {
            get { return count; }
        }

        public Counter()
        {
            thisLock = new object();
            count = 0;
        }

        public void Increase()
        {
            int loopCount = LOOP_COUNT;
            while (loopCount-- > 0)
            {
                lock (thisLock)
                {
                    count++;
                }
                Thread.Sleep(1);
            }
        }

        public void Decrease()
        {
            int loopCount = LOOP_COUNT;
            while(loopCount-- > 0)
            {
                lock (thisLock)
                {
                    count--;
                }
                Thread.Sleep(1);
            }
        }
    }

    class MainApp
    {
        static void Main(string[] args)
        {
            Counter counter = new Counter();    

            Thread incThread = new Thread(new ThreadStart(counter.Increase));
            Thread decThread = new Thread(new ThreadStart(counter.Decrease));
        
            incThread.Start();
            decThread.Start();  

            incThread.Join();
            decThread.Join();

            Console.WriteLine(counter.Count);
        }
    }
}
```
```java
Output

0
```

<br />

#### Monitor 클래스로 동기화하기 

- `Monitor` 클래스는 스레드 동기화에 사용하는 몇가지 정적 메소드를 제공
- 가장 먼저 확인할 메소드는 `Monitor.Enter()`와 `Monitor.Exit()` => 이 두 메소드는 lock 키워드와 완전히 똑같은 기능
- `Monitor.Enter()` => 크리티컬 섹션을 만듬
- `Monitor.Exit()` => 크리티컬 섹션을 제거

<br />

##### `lock` 키워드와 `Monitor.Enter() & Monitor.Exit()` 비교
```csharp
lock 키워드 사용 경우

public void Increase()
{
    int loopCount = 1000;
    while(loopCount-- > 0)
    {
        lock (thisLock){
            count++
        }
    }
}

```
```csharp
Monitor 클래스 메소드 사용 경우

public void Increase()
{
    int loopCount = 1000;
    while(loopCount-- > 0)
    {
        Monitor.Enter(thisLock);
        try
        {
            count++;
        }
        finally
        {
            Monitor.Exit(thisLock);
        }
    }
}
```

<br />

- 거의 비슷한 형태를 하고 있다. 
- `lock` 키워드는 `Monitor.Enter() 와 Monitor.Exit()`메소드를 바탕으로 구현되어 있다.
- 따라서 `Monitor.Enter() 와 Monitor.Exit()` 을 이용해 동기화를 할 것 같다면 차라리 `lock` 키워드로 동기화를 하는 것이 프로그램 버그면 혹은 코드 작성면에서 더 편리하다.

##### `Monitor.Enter() & Monitor.Exit()` 사용예제 코드

``` csharp
using System;
using System.Threading;

namespace SynchronizeUsingMonitor
{
    class Counter
    {
        const int LOOP_COUNT = 1000;

        readonly object thisLock;

        private int count;
        public int Count
        {
            get { return count; }
        }

        public Counter()
        {
            thisLock = new object();
            count = 0;
        }

        public void Increase()
        {
            int loopCount = LOOP_COUNT;
            while (loopCount-- > 0)
            {
                Monitor.Enter(thisLock);
                try
                {
                    count++;
                }
                finally
                {
                    Monitor.Exit(thisLock);
                }
                Thread.Sleep(1);
            }
        }

        public void Decrease()
        {
            int loopCount = LOOP_COUNT;
            while (loopCount-- > 0)
            {
                Monitor.Enter(thisLock);
                try
                {
                    count--;
                }
                finally
                {
                    Monitor.Exit(thisLock);
                }
                Thread.Sleep(1);
            }
        }

        class MainApp
        {
            static void Main(string[] args)
            {
                Counter counter = new Counter();

                Thread incThread = new Thread(new ThreadStart(counter.Increase));
                Thread decThread = new Thread(new ThreadStart(counter.Decrease));

                incThread.Start();
                decThread.Start();

                incThread.Join();
                decThread.Join();

                Console.WriteLine(counter.Count);
            }
        }
    }
}
```

```java
Output

0
```

- 참고로 예제코드는 `count` 값이 1000번 1증가 1000번 1감소하는 코드임 

<br />

<!-- 다음 공부시 586page의 Monitor.Wait() & Monitor.Pulse() 부터 시작 -->
