## 스레드와 태스크
--------

<br />

- `프로세스(Process)` : 실행파일이 실행되어 메모리에 적재된 인스턴스
- 프로세스는 하나 이상의 `스레드(Thread)`로 구성된다.
- 스레드는 운영체제가 CPU를 할당하는 기본단위이며, 프로세스가 밧줄이라면, 스레드는 밧줄을 이루고 있는 실이라고 할 수 있다.

#### 멀티 스레드(Multi-Thread)를 이용했을때의 장단점.

<br />

##### 장점

1. 사용자 대화형 프로그램에서(콘솔 프로그램과 GUI프로그램 모두) 멀티스레드를 이용하면 응답성을 높일 수 있다는 점을 꼽을 수 있다.
    - 예를 들어 우리가 만든 프로그램을 파일을 복사하는데, 복사할 피일이 너무 커서 소요시간이 30분정도 걸린다고 가정해보자. 이 때 프로그램을 단일 스레드로 만든다면 프로그램이 파일을 복사하는 동안 사용자가 취소 명령을 내리고 싶어도 프로그램이 사용자에게 반응하지 않으므로, 복사를 취소할 수가 없다. 작업관리자를 이용해 강제로 프로세스를 종료시키지 않는 한.. 이 프로그램에 사용자와의 대화를 위한 스레드를 하나 더 추가한다면 파일복사를 하면서도 사용자로부터 명령을 받을 수 있다. 
  
  <br />

2. 멀티 프로세스 방식에 비해 멀티 스레드 방식이 자원공유가 더 쉽다는 점이 있다. 
      - 멀티 프로세스는 GUI가 없는 웹서버같은 서버용 애플리케이션에서 많이 취하는 구조인데, 프로세스끼리 데이터를 교환하려면 소켓이나 공유 메모리 같은 IPC(Inter Process Communication)를 이용해야 한다. 반면 멀티 스레드 방식에서는 그저 스레드끼리 코드 내의 변수를 같이 사용하는 것만으로도 데이터 교환을 할 수 있다. 

<br />

3. 프로세스를 띄우기 위해 메모리와 자원을 할당하는 작업은 (CPU 사용시간등의) 비용이 비싼데, 스레드를 띄울때는 이미 프로세스에 할당된 메모리와 자원을 그대로 사용하므로 메모리와 자원을 할당하는 비용을 지불하지 않아도 된다.

<br />

##### 단점

1. 구현하기가 매우 까다롭다.
2. 테스트하기가 쉽지 않다.
3. 멀티 프로세스 기반의 소프트웨어는 여러 개의 자식프로세스 중 하나에 문제가 생기면 영향이 확산되지 않지만, 멀티 스레드 기반의 소프트웨어에서는 자식 스레드 중 하나에 문제가 생기면 전체에 영향을 미친다.
4. 멀티스레드에서 스레드를 너무 많이 사용하면 오히려 성능이 저하되는 문제가 생길 수 있다.
    - 스레드가 CPU를 사용하기 위해 작업 간 전환(Context Switching)을 해야하는데, 이 작업간 전환이 많은 비용을 소모한다. 많은 스레드가 너무 자주 작업 간 전환을 수행하다 보면 애플리케이션이 실제로 일을 하는 시간에 비해 작업 간 전환에 사용하는 시간이 커지기 때문에 성능이 저하된다.

#### 스레드 시작하기

```csharp
1. Thread의 인스턴스를 생성한다. 이 때 생성자의 매개변수로 스레드가 실행할 메소드를 매개변수로 넘긴다.
2. Thread.Start() 메소드를 호출하여 스레드를 시작한다.
3. Thread.Join() 메소드를 호출하여 스레드가 끝날 때까지 기다린다.
```

```csharp
using System;
using System.Threading;

namespace ThreadEx
{

    class MainApp
    {
        static void DoSomething() // 스레드가 실행할 메소드
        {
            for(int i = 0; i < 5; i++)
            {
                Console.WriteLine($"DoSomething : {i}");
            }
            Thread.Sleep(10); 
            //sleep 메소드는 다른쓰레드도 CPU를 사용할 수 있도록, CPU점유를 내려놓는다. 매개변수는 밀리초 단위이다.
        }

        static void Main(string[] args)
        {
            Thread t1 = new Thread(new ThreadStart(DoSomething)); // Thread의 인스턴스 생성

            Console.WriteLine("Start Threading...");
            t1.Start(); // 스레드 시작

            for(int i = 0; i < 5; i++)
            {
                Console.WriteLine($"Main : {i}");
                Thread.Sleep(10);   
            }

            Console.WriteLine("Wating until thread stops...");
            t1.Join(); // 스레드의 종료 대기

            Console.WriteLine("Finished");
        }
    }
} 
```

```java
Output

Start Threading...
Main : 0
DoSomething : 0
DoSomething : 1
DoSomething : 2
DoSomething : 3
DoSomething : 4
Main : 1
Main : 2
Main : 3
Main : 4
Wating until thread stops...
Finished
```

<br />

#### 스레드 임의로 종료시키기.

```csharp

Thread t1 = new Thread(new ThreadStart(DoSomething)); // Thread의 인스턴스 생성

t1.Start();

t1.Abort(); // => 스레드 취소 종료

t1.Join();

```

- `Abort()`메소드는 선언 후 join메소드를 이용해 기다렸다가 합쳐줘야함. Abort()자체적으로 처리 시간을 조금은 염두해야하기에..

- 프로그래머들 사이에서 Abort 메소드의 사용은 `금기시` 되어있기에 `가급적 사용하지 않는것을 추천`한다. => 잘못하면 공유자원이 잠긴채로 쓰레드가 종료되어 다른 스레드에서도 접근하지 못할 수 있음.

``` csharp
using System;
using System.Threading;

namespace ThreadEx
{
    class SideTask
    {
        int count;

        public SideTask(int count)
        {
            this.count = count;
        }

        public void KeepAlive()
        {
            try
            {
                while(count > 0)
                {
                    Console.WriteLine($"{count--} left");
                    Thread.Sleep(10);
                }
                Console.WriteLine("count : 0");
            }
            catch(ThreadAbortException e)
            {
                Console.WriteLine(e);
                Thread.ResetAbort();
            }
            finally
            {
                Console.WriteLine("Clearing resource...");
            }
        }
    }
    class MainApp
    {
        static void Main(string[] args)
        {
            SideTask st = new SideTask(100);
            Thread t1 = new Thread(new ThreadStart(st.KeepAlive));
            t1.IsBackground = false;

            Console.WriteLine("Starting thread ... ");
            t1.Start();

            Thread.Sleep(100);

            Console.WriteLine("Aborting thread ... ");
            t1.Abort();

            Console.WriteLine("Waiting until thread stops ... ");
            t1.Join();

            Console.WriteLine("Finished");
        }
    }
} 
```
```java
Output

Starting thread ...
100 left
99 left
98 left
97 left
96 left
95 left
94 left
Aborting thread ...
93 left
Unhandled exception. 92 left
System.PlatformNotSupportedException: Thread abort is not supported on this platform.
   at System.Threading.Thread.Abort()
   at ThreadEx.MainApp.Main(String[] args) in C:\Users\shkim\source\repos\ClassEx\practice1\Program.cs:line 51
91 left
90 left
89 left
88 left
87 left
86 left
85 left
```

- 현재 사용하고 있는 플랫폼에서 지원하지 않는듯함.

```csharp
프로그래머들 사이에서 Abort 메소드의 사용은 `금기시` 되어있기에 `가급적 사용하지 않는것을 추천`한다. 
=> 잘못하면 공유자원이 잠긴채로 쓰레드가 종료되어 다른 스레드에서도 접근하지 못할 수 있음.
```

- 위와 같은 이유 때문에 지원하지 않는 것일지도 모르겠음..

<br />

#### 스레드의 일생과 상태 변화 

|상태|설명|
|:---:|---|
|Unstarted|스레드 객체를 생성한 후 Thread.Start() 메소드가 호출되기 전의 상태|
|Running|스레드가 시작하여 동작중인 상태를 나타냅니다. Unstarted 상태의 스레드를 Thread.Start()메소드를 통해 이 상태로 만들 수 있음|
|Suspended|스레드의 일시 중단 상태를 나타낸다. 스레드를 Thread.Suspend() 메소드를 통해 이 상태로 만들 수 있으며, Suspended상태인 스레드는 Thread.Resume() 메소드를 통해 다시 Running 상태로 만들 수 있음.|
|WaitSleepJoin|스레드가 블록(Block)된 상태를 나타냄. 상태이름이 block이 아닌 WaitSleepJoin인 이유는 스레드에 대해 Monitor.Enter(), Thread.Sleep() 또는 Thread.Join() 메소드를 호출하면 이 상태가 되기 때문.|
|Aborted|스레드가 취소된 상태를 나타낸다. Thread.Abort() 메소드를 호출하면 이 상태가 됨. Aborted 상태가 된 스레드는 다시 Stopped 상태로 전환되어 완전히 중지됨.|
|Stopped|중지된 스레드의 상태를 나타냄. Abort() 메소드를 호출하거나 스레드가 실행중인 메소드가 종료되면 이 상태가 됨.|
|Background|스레드가 백그라운드로 동작하고 있음을 나타냄. Foreground 스레드는 하나라도 살아있는한 프로세스가 죽지 않지만, 백그라운드 프로세스는 스레드가 하나가 아니라 10개가 살아있어도 프로세스가 죽고 사는 것에는 영향을 미치지 않음. 하지만 프로세스가 죽으면 백그라운드 스레드들도 모두 죽음. Thread.IsBackground 속성에 true값을 입력함으로써 스레드를 이상태로 바꿀 수 있음.|

- 이들 ThreadState 열거형의 멤버들은 Flags 어트리뷰트를 가지고 있다. 
- Flags 속성은 자신이 수식하는 열거형을 비트 필드, 즉 플래그 집합으로 처리할 수 있음을 나타냅니다. 
- 스레드는 두가지 이상의 상태를 가질 수 있다. => 이 두가지 이상의 상태를 표현하기 위해 이 Flags 어트리뷰트가 수식되어있는것.

<br />

##### 비트 필드(Bit Field)

- 스레드는 동시에 두 가지 이상의 상태를 가질 수 있음
- 예를들어 Suspended 상태이면서 WaitSleepJoin 상태를 가질 수도 있고, Background 상태이면서 Stopped 상태일 수도 있음
- ThreadState는 두 가지 이상의 상태를 동시에 표현하기 위해 이 Flags 애트리뷰트가 수식되어 있음
  - `Flags` => 자신이 수식하는 열거형을 비트필드(Bit Field),즉 플래그 집합으로 처리할 수 있음을 나타냄

```csharp
using System;
using System.Threading;

namespace UsingThreadState
{
    class MainApp
    {
        private static void PrintThreadState(ThreadState state)
        {
            Console.WriteLine("{0,-16} : {1}", state,(int) state);
        }

        static void Main(string[] args)
        {
            PrintThreadState(ThreadState.Running);
            PrintThreadState(ThreadState.StopRequested);
            PrintThreadState(ThreadState.SuspendRequested);
            PrintThreadState(ThreadState.Background);
            PrintThreadState(ThreadState.Unstarted);
            PrintThreadState(ThreadState.Stopped);
            PrintThreadState(ThreadState.WaitSleepJoin);
            PrintThreadState(ThreadState.Suspended);
            PrintThreadState(ThreadState.AbortRequested);
            PrintThreadState(ThreadState.Aborted);
            PrintThreadState(ThreadState.Aborted | ThreadState.Stopped);
        }
    }
}
```
```java
Output

Running          : 0
StopRequested    : 1
SuspendRequested : 2
Background       : 4
Unstarted        : 8
Stopped          : 16
WaitSleepJoin    : 32
Suspended        : 64
AbortRequested   : 128
Aborted          : 256
Stopped, Aborted : 272
```

- `ThreadState` 필드를 통해 상태를 확인할 때는 반드시 비트연산을 이용해야 한다.
- `ThreadState` 열거형이 여러 상태를 동시에 나타낼 수 있도록 만들어져 있다.


<br />

##### 비트필드를 이용해 표현한 쓰레드의 상태

|상태|십진수|이진수|
|:----:|:----:|:----:|
|Running|0|000000000|
|StopRequested|1|000000001|
|SuspendedRequested|2|000000010|
|Background|4|000000100|
|Unstarted|8|000001000|
|Stopped|16|000010000|
|WatiSleepJoin|32|000100000|
|Suspended|64|001000000|
|AbortRequested|128|010000000|
|Aborted|256|100000000|

<br />


#### 인터럽트(Interrupt) : 스레드를 임의로 멈추는 또 하나의 방법

- 본래 스레드는 수명을 다해 스스로 종료하는 것이 가장 좋다. 불가피하게 스레드를 강제로 종료시켜야 하는 경우가 있다. 하지만 Thread.Abort() 메소드는 너무 무자비하다. Abort()메소드를 사용할때는 도중에 강제로 중단된다 해도 프로세스 자신이나 시스템에 영향이 없는 작업에 한해 사용하는 것이 좋다. 
- 스레드가 수행 중인 작업이 강제로 중단되는 경우 시스템에 악영향을 미칠 수 있다면 조금 더 부드러운 방법을 택해야 한다.
- `Thread.Interrupt()` 메소드는 스레드가 한참 동작중인 상태(Running 상태)를 피해서 `WaitJoinSleep` 상태에 들어갔을 때 `ThreadInterruptedException` 예외를 던져 스레드를 중지시킨다. => 이러한 특징 때문에 프로그래머는 최소한 코드가 "절대로 중단되면 안되는" 작업을 하고 있을 때는 중단되지 않는다는 보장을 받을 수 있음

```csharp
using System;
using System.Security.Permissions;
using System.Threading;

namespace InterruptingThread
{
    class SideTask
    {
        int count;

        public SideTask(int count)
        {
            this.count = count;
        }

        public void KeepAlive()
        {
            try
            {
                Console.WriteLine("Running thread isn't gonna be interrupted");
                Thread.SpinWait(1000000000);
                // SpinWait() 메소드는 원래 사용할 일이 별로 없다
                // 이 메소드는 Sleep()과 유사하게 스레드를 대기하게 하지만 Sleep()과 달리 스레드가 Running 상태를 유지하게함/.
                 
                while(count > 0)
                {
                    Console.WriteLine("{0} left", count--);

                    Console.WriteLine("Entering into WaitJoinSleep State...");
                    Thread.Sleep(10);
                }
                Console.WriteLine("Count : 0");
            }
            catch(ThreadInterruptedException e)
            {
                Console.WriteLine(e);
            }
            finally
            {
                Console.WriteLine("Clearing resource ...");
            }
        }
    }    
    class MainApp
    {
        static void Main(string[] args)
        {
            SideTask task = new SideTask(100);
            Thread t1 = new Thread(new ThreadStart(task.KeepAlive));
            t1.IsBackground = false;

            Console.WriteLine("Starting thread...");
            t1.Start();

            Thread.Sleep(100);

            Console.WriteLine("Interrupting thread...");
            t1.Interrupt();

            Console.WriteLine("Waiting until thread stops...");
            t1.Join();

            Console.WriteLine("Finished");
        }
    }
}
```
```java
Output

Starting thread...
Running thread isn't gonna be interrupted
Interrupting thread...
Waiting until thread stops...
100 left
Entering into WaitJoinSleep State...
System.Threading.ThreadInterruptedException: Thread was interrupted from a waiting state.
   at System.Threading.Thread.SleepInternal(Int32 millisecondsTimeout)
   at System.Threading.Thread.Sleep(Int32 millisecondsTimeout)
   at InterruptingThread.SideTask.KeepAlive() in C:\Users\shkim\source\repos\ClassEx\practice1\Program.cs:line 30
Clearing resource ...
Finished
```

- `Main`메소드 내 `Interrupt()` 메소드를 호출하는 시점에 스레드가 `Running` 상태를 유지하도록 하기 위해 `SpinWait()` 메소드를 사용
- 해당 `Main`문 내 `interrupt()` 메소드가 호출된 스레드는 `KeepAlive` 메소드 내의 `sleep(10)`에 의해 `WaitSleepJoin` 상태로 들어가고 이때 `인터럽트`가 발생함.

<br />

#### 스레드 간의 동기화

- 애플리케이션을 구성하는 각 스레드는 여러가지 자원을 공유하는 경우가 많다.
    Ex) 파일 핸들이나 네트워크 커넥션, 메모리에 선언한 변수 등
- 각각의 스레드는 본래 다른 스레드가 어떤 자원을 사용하고 있건 상관없이 갑자기 끼어들어 자기 제멋대로 사용해버리는 경우가 다반사이다. 이러한 스레드의 기질을 그대로 두면 소프트웨어들은 모두 엉망이 되어버릴 것임. => 즉, 스레드들이 정연하게 자원을 사용할 수 있도록 질서를 잡아야함
  - 이처럼 스레드들이 순서를 갖추어 자원을 사용하게 하는 것을 일컬어 "`동기화(Synchronization)`" 라고 함. 
  - 이 `동기화` 작업을 제대로 하는 것이야말로 `멀티 스레드 프로그래밍`을 완벽하게 하는 길
- 스레드 동기화에서 가장 중요한 사항은 `자원을 한번에 하나의 스레드가 사용하도록 보장` 하는 것이다. 
  - 이를 달성하기 위해 `.Net` 프레임워크에서는 `lock` 키워드와 `Monitor` 클래스를 제공한다. => 하는 일은 `lock` 키워드와 `Monitor` 클래스 둘 다 비슷하지만 사용하기는 `lock` 키워드가 사용하기 쉽지만 섬세한 동기화 제어 기능은 `Monitor`클래스를 통해 제공한다. => 상황에 맞춰 사용하라는 말이겠쥬~?

<br />

#### lock 키워드로 동기화하기

- `크리티컬 섹션(Critical Section)` : 한번에 한 스레드만 사용할 수 있는 코드영역 => 해당 코드 영역에는 한 번에 한 스레드 혹은 프로세스만 사용가능한 자원이 존재하기에 뮤텍스(Mutex) 또는 세마포어(Semaphore)를 통해 제어해준 것 같은 기억이 있다.
- C# 에서는 `lock`키워드로 감싸주기만 해도 평범한 코드를 크리티컬 섹션으로 바꿀 수 있다.

```csharp
using System;
using System.Threading;

class Counter
{
    public int count = 0;

    public void Increase()
    {
        count += 1;
    }
}

class Program
{
    static void Main(string[] args)
    {
        Counter obj = new Counter();
        Thread t1 = new Thread(new ThreadStart(obj.Increase));
        Thread t2 = new Thread(new ThreadStart(obj.Increase));
        Thread t3 = new Thread(new ThreadStart(obj.Increase));
    
        t1.Start();
        t2.Start();
        t3.Start();

        t1.Join();
        t2.Join();
        t3.Join();
    
        Console.WriteLine(obj.count);
    }
}
```

- 위의 코드는 스레드들이 사이가 좋다면 결과가 3이 나올 것이다
- 하지만 결과값의 범위는 1 ~ 3 이다.
- 언제 어떤 스레드가 `obj`의 `Increase()` 메소드에서 `count` 값을 사용할지 모르기 때문이다
  - `count` => 공유 자원
- 이러한 문제를 해결하기위해서 `count += 1` 코드를 한 스레드가 실행하고 있을 때 다른 스레드에서 접근하지 못하도록하는 장치가 필요함.
- 여기서 `lock`키워드를 사용

```csharp
using System;
using System.Threading;

class Counter
{
    public int count = 0;
    private readonly object thisLock = new object();    

    public void Increase()
    {
        lock ( thisLock )
        { 
        count += 1;
        }
    }
}

class Program
{
    static void Main(string[] args)
    {
        Counter obj = new Counter();
        Thread t1 = new Thread(new ThreadStart(obj.Increase));
        Thread t2 = new Thread(new ThreadStart(obj.Increase));
        Thread t3 = new Thread(new ThreadStart(obj.Increase));
    
        t1.Start();
        t2.Start();
        t3.Start();

        t1.Join();
        t2.Join();
        t3.Join();
    
        Console.WriteLine(obj.count);
    }
}
```
```java
Output

3
```
- 위에서 처럼 `lock` 키워드를 사용하는 것은 간단함
- 여기서의 동작은 각각의 스레드들이 `lock()`의 매개변수로 있는 `thisLock`을 돌려가며 해당 `thisLock`을 가지고 있는 스레드들만이 `크리티컬 섹션`에 접근할 수 있다.
- 이 과정에서 `thisLock`을 얻지 못한 스레드들은 `thisLock`을 달라고 옆에서 징징거리는데 이런 경우 소프트웨어의 성능이 크게 떨어진다. => 따라서 스레드의 동기화를 설계할 때는 크리티컬 섹션을 반드시 필요한 곳에서만 사용하도록 하는 것이 중요하다.

<br />

- 한편 `lock` 키워드의 매개변수로 사용하는 객체는 참조형이면 어느 것이든 사용할 수 있지만 public 키워드 등을 통해 외부 코드에서도 접근할 수 있는 다음 세가지는 절대 사용하지 않기를 권함
    -  문법적으로 문제가 없어 컴파일시에 에러가 나오지 않아 더 골치아픔

|객체| 설명|
|:-----:|:-----:|
|this| 클래스의 인스턴스는 클래스 내부뿐만 아니라 외부에서도 자주 사용된다. 자주 정도가 아니고 거의 항상그렇기에 `lock(this)`는 나쁜 버릇! |
|Type 형식|`typeof` 연산자나 `object` 클래스로부터 물려받은 `GetType()` 메소느는 `Type` 형식의 인스턴스를 반환한다. 즉, 코드의 어느 곳에서나 특정 형식에 대한 `Type` 객체를 얻을 수 있다. `lock(typeof(SomeClass))` 나 `lock(obj.GetType())` 은 피해라 제발! |
|string 형식|절대 `string` 객체로 `lock` 하지 마라 `"abc"` 는 어떤 코드에서든 얻어낼 수 있는 `string 객체`입니다. `lock("abc")` 같은 코드를 쓰는 짓은 피해라! |


<br />

##### lock 키워드로 동기화하기 사용 예제 
```csharp
using System;
using System.Threading;

namespace Synchronize
{
    class Counter
    {
        const int LOOP_COUNT = 1000;

        readonly object thisLock;

        private int count;
        public int Count
        {
            get { return count; }
        }

        public Counter()
        {
            thisLock = new object();
            count = 0;
        }

        public void Increase()
        {
            int loopCount = LOOP_COUNT;
            while (loopCount-- > 0)
            {
                lock (thisLock)
                {
                    count++;
                }
                Thread.Sleep(1);
            }
        }

        public void Decrease()
        {
            int loopCount = LOOP_COUNT;
            while(loopCount-- > 0)
            {
                lock (thisLock)
                {
                    count--;
                }
                Thread.Sleep(1);
            }
        }
    }

    class MainApp
    {
        static void Main(string[] args)
        {
            Counter counter = new Counter();    

            Thread incThread = new Thread(new ThreadStart(counter.Increase));
            Thread decThread = new Thread(new ThreadStart(counter.Decrease));
        
            incThread.Start();
            decThread.Start();  

            incThread.Join();
            decThread.Join();

            Console.WriteLine(counter.Count);
        }
    }
}
```
```java
Output

0
```

<br />

#### Monitor 클래스로 동기화하기 

- `Monitor` 클래스는 스레드 동기화에 사용하는 몇가지 정적 메소드를 제공
- 가장 먼저 확인할 메소드는 `Monitor.Enter()`와 `Monitor.Exit()` => 이 두 메소드는 lock 키워드와 완전히 똑같은 기능
- `Monitor.Enter()` => 크리티컬 섹션을 만듬
- `Monitor.Exit()` => 크리티컬 섹션을 제거

<br />

##### `lock` 키워드와 `Monitor.Enter() & Monitor.Exit()` 비교
```csharp
lock 키워드 사용 경우

public void Increase()
{
    int loopCount = 1000;
    while(loopCount-- > 0)
    {
        lock (thisLock){
            count++
        }
    }
}

```
```csharp
Monitor 클래스 메소드 사용 경우

public void Increase()
{
    int loopCount = 1000;
    while(loopCount-- > 0)
    {
        Monitor.Enter(thisLock);
        try
        {
            count++;
        }
        finally
        {
            Monitor.Exit(thisLock);
        }
    }
}
```

<br />

- 거의 비슷한 형태를 하고 있다. 
- `lock` 키워드는 `Monitor.Enter() 와 Monitor.Exit()`메소드를 바탕으로 구현되어 있다.
- 따라서 `Monitor.Enter() 와 Monitor.Exit()` 을 이용해 동기화를 할 것 같다면 차라리 `lock` 키워드로 동기화를 하는 것이 프로그램 버그면 혹은 코드 작성면에서 더 편리하다.

##### `Monitor.Enter() & Monitor.Exit()` 사용예제 코드

``` csharp
using System;
using System.Threading;

namespace SynchronizeUsingMonitor
{
    class Counter
    {
        const int LOOP_COUNT = 1000;

        readonly object thisLock;

        private int count;
        public int Count
        {
            get { return count; }
        }

        public Counter()
        {
            thisLock = new object();
            count = 0;
        }

        public void Increase()
        {
            int loopCount = LOOP_COUNT;
            while (loopCount-- > 0)
            {
                Monitor.Enter(thisLock);
                try
                {
                    count++;
                }
                finally
                {
                    Monitor.Exit(thisLock);
                }
                Thread.Sleep(1);
            }
        }

        public void Decrease()
        {
            int loopCount = LOOP_COUNT;
            while (loopCount-- > 0)
            {
                Monitor.Enter(thisLock);
                try
                {
                    count--;
                }
                finally
                {
                    Monitor.Exit(thisLock);
                }
                Thread.Sleep(1);
            }
        }

        class MainApp
        {
            static void Main(string[] args)
            {
                Counter counter = new Counter();

                Thread incThread = new Thread(new ThreadStart(counter.Increase));
                Thread decThread = new Thread(new ThreadStart(counter.Decrease));

                incThread.Start();
                decThread.Start();

                incThread.Join();
                decThread.Join();

                Console.WriteLine(counter.Count);
            }
        }
    }
}
```

```java
Output

0
```

- 참고로 예제코드는 `count` 값이 1000번 1증가 1000번 1감소하는 코드임 

<br />

#### Monitor.Wait()과 Monitor.Pulse()로 하는 저수준 동기화

- `Monitor.Wait()`과 `Monitor.Pulse()` 는 단순히 `lock` 키워드만을 사용할 때보다 더 섬세하게 멀티 스레드간의 동기화를 가능하게 한다.

- 단, 해당 두 메소드는 반드시 `lock` 블록 내부에서만 호출해야 한다. 만일 `lock`을 걸지 않은 상태에서 두 메소드를 호출한다면 `CLR`이 `SynchronizaionLockException` 예외를 던진다.

- `Wait` 메소드는 스레드를 `WaitSleepJoin` 상태로 만들고 이렇게 `WaitSleepJoin` 상태에 들어간 스레드는 동기화를 위해 가지고 있던 `lock`을 내려놓은 뒤 `Waiting Queue`라고 하는 큐에 입력되고, 다른 스레드가 `lock`을 얻어 작업함. 이후 작업을 수행하던 스레드가 작업을 마친 뒤 `Pulse`메소드를 호출하면 `CLR`은 `Waiting Queue`의 가장 첫 요소 스레드를 꺼낸 뒤 `Ready Queue`에 입력함. `Ready Queue`에 입력된 스레드는 입력된 차례에 따라 `lock`을 얻어 `Running` 상태에 들어감. => 즉, 다시 작업을 수행한다는 말. 

<br />

##### Wait과 Pulse 메소드를 호출할 때 일어나는 일

<span align="center">

![Wait과 Pulse 메소드를 호출할 때 일어나는 일](images/Wait%26Pulse_running_image.PNG)


</span>

- 한편, `ThreaSleep()` 메소드도 스레드를 `WaitSleepJoin` 상태로 만들기는 하지만 `Monitor.Pulse()` 메소드에 의해 깨어날 수 없다.(`Waiting Queue`에 들어가지도 않고.. ㅇㅇ) 다시 Running 상태로 돌아오려면 매개변수로 입력된 시간이 경과되거나 `Interrupt()` 메소드 호출에 의해 인터럽트 예외를 받아야 깨어난다.
- 반면에 `Monitor.Wait()` 메소드는 `Monitore.Pulse()` 메소드가 호출되면 바로 깨어날 수 있다.
- 이러한 이유 때문에 멀티 스레드 애플리케이션의 성능향상을 위해서 `Monitor.Wait()` 과 `Monitor.Pulse()`를 사용하는 것이다.

<br />

##### Wait(), Pulse() 메소드 사용 예제 코드

<br />

```csharp
using System;
using System.Threading;

namespace WaitPulse
{
    class Counter
    {
        const int LOOP_COUNT = 1000;

        readonly object thisLock;
        bool lockedCount = false;

        private int count;
        public int Count
        {
            get { return count; }
        }

        public Counter()
        {
            thisLock = new object();
            count = 0;
        }

        public void Increase()
        {
            int loopCount = LOOP_COUNT;
            while(loopCount-- > 0)
            {
                lock (thisLock)
                {
                    while(count > 0 || lockedCount == true)
                    {
                        Monitor.Wait(thisLock);
                    }

                    lockedCount = true;
                    count++;
                    lockedCount = false;

                    Monitor.Pulse(thisLock);
                }
            }
        }

        public void Decrease()
        {
            int loopCount = LOOP_COUNT;
            while (loopCount-- > 0)
            {
                lock (thisLock)
                {
                    while (count < 0 || lockedCount == true)
                    {
                        Monitor.Wait(thisLock);
                    }

                    lockedCount = true;
                    count--;
                    lockedCount = false;

                    Monitor.Pulse(thisLock);
                }
            }
        }
    }

    class MainApp
    {
        static void Main(string[] args)
        {
            Counter counter = new Counter();

            Thread incThread = new Thread(new ThreadStart(counter.Increase));
            Thread decThread = new Thread(new ThreadStart(counter.Decrease));

            incThread.Start();
            decThread.Start();

            incThread.Join();
            decThread.Join();   

            Console.WriteLine(counter.Count);

        }
    }
}
```

```java
Output

0
```

- `Thread.Join()` : `Join()` 메서드는 현재 스레드에서 다른 스레드의 실행이 끝나길 기다릴 때 사용하는 메서드이다. => 위의 코드에서는 `Main`메서드에서 각각의 스레드에 `Join`메소드를 호출함으로써 두개의 스레드의 종료를 기다린다.
- `incThread` 및 `decThread` 두개의 스레드가 각기 번갈아가며 실행하는 예제 따라서 `0`이 출력됨. => 이해안되면 다시 코드 천천히 따라가보자

<br />

### Task와 Task\<TResult>, 그리고 Parallel

<br />

#### 병렬처리와 비동기 처리의 차이

- 병렬 처리와 비동기 처리는 비슷한 용어 같지만 다른 뜻이다. 하나의 작업을 여러 작업자가 나눠서 수행한 뒤 다시 하나의 결과로 만드는 것을 병렬 처리라 하고, 이에 비해 비동기 처리는 작업 A를 시작한 후 A의 결과가 나올 때까지 마냥 대기하는 대신 곧이어 다른 작업 B, C, D .. 를 수행하다가 작업 A가 끝나면 그 때 결과를 받아내는 처리방식을 말한다.

<br />

#### System.Threading.Tasks vs Thread 클래스

- `System.Threading.Tasks` 네임스페이스의 클래스들은 하나의 작업을 쪼갠 뒤 쪼개진 작업들을 동시에 처리하는 코드와 비동기 코드를 위해 설계되었다. 반면에 `Thread` 클래스는 여러 개의 작업을 (나누지 않고) 각각 처리해야 하는 코드에 적합하다. `Thread` 클래스로도 하나의 작업을 쪼개 처리하는 코드와 비동기 코드를 작성할 수는 있지만 (`Task`등의 클래스들도 내부적으로는 `Thread`를 이용해 구현되었음), `System.Threading.Tasks`의 클래스들을 이용하는 것보다는 훨씬 힘들다. 

<br />

#### System.Threading.Tasks.Task 클래스

- `System.Threading.Tasks.Task` 클래스는 비동기 코드를 손쉽게 작성할 수 있도록 도와줌 
- `동기코드`는 메소드를 호출한 뒤에 이 메소드의 실행이 완전히 종료되어야만 다음 메소드를 호출할 수 있다.
- `비동기코드`는 메소드를 호출한 뒤에 메소드의 종료를 기다리지 않고 바로 다음 코드를 실행한다.
- 비동기로 동작하는 메소드는 다음 절에서 `async` 한정자와 `await` 연산자를 이용해 구현할 수 있다. 
- Task 클래스는 인스턴스를 생성할 때 `Action` 델리게이트를 넘겨받는다. => 반환형을 갖지 않는 메소드와 익명메소드, 무명함수등을 넘겨받는 것

##### System.Threading.Tasks.Task 클래스 사용 예제 코드

```csharp
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace UsingTask
{
    class MainApp
    {
        static void Main(string[] args)
        {
            string srcFile = args[0];
            
            Action<object> FileCopyAction = (object state) =>
            {
                String[] paths = (String[])state;
                File.Copy(paths[0], paths[1]);
                
                Console.WriteLine("TaskID : {0}, ThreadID : {1}, {2} was copied to {3}", Task.CurrentId, Thread.CurrentThread.ManagedThreadId, paths[0], paths[1]);
            };

            Task t1 = new Task(FileCopyAction, new string[] { srcFile, srcFile + ".copy1" });
            // Task() 생성자의 두번째 매개변수는 첫번째 매개변수(Action 델리게이트 or 익명 메소드 or 무명함수) 의 매개변수로 사용됨

            Task t2 = Task.Run(() =>
            {
                FileCopyAction(new string[] { srcFile, srcFile + ".copy2" });
            });
            t2.Wait();

            t1.Start();
            t1.Wait();

            Task t3 = new Task(FileCopyAction, new string[] { srcFile, srcFile + ".copy3" });
            t3.RunSynchronously();
            t3.Wait();
        }
    }
}
```
```java
Output

C:\Users\shkim\source\repos\ClassEx\practice1>dotnet run c:\test\a.txt
TaskID : 1, ThreadID : 4, c:\test\a.txt was copied to c:\test\a.txt.copy2
TaskID : 2, ThreadID : 6, c:\test\a.txt was copied to c:\test\a.txt.copy1
TaskID : 3, ThreadID : 1, c:\test\a.txt was copied to c:\test\a.txt.copy3
```

<span align="center">

![UsingTask 결과 이미지](images/UsingTask%20%EA%B2%B0%EA%B3%BC%20%EC%9D%B4%EB%AF%B8%EC%A7%80.PNG)

</span>

- 교재에 제시된 코드와는 차이가 있다. 교재에서는 마지막에 Wait()함수들을 한번에 호출하는데, 그렇게 되면 원하는 결과를 얻을 수 없다. => 같은 파일에 대해 계속해서 스레드를 할당시키기 때문에 순서가 뒤죽박죽이 된다.
- 따라서 각각의 스레드를 실행한 순서대로 뒤에 Wait() 메소드를 이용해 순서가 섞이지 않도록 해준다.

<br />

##### Thread.Join() 과 Task.Wait()
- `Thread.Join()` => 스레드가 다른 스레드가 완료될 때까지 기다리려면 Join 메소드를 사용해야 합니다. 
  - 예를 들어 스레드 t1이 t2.join()을 실행하면 t1은 t2가 완료될 때까지 대기 상태가 됩니다.
- `Task.Wait()` => `Task`의 실행이 완료되기를 기다립니다.

<br />

#### Task\<TResult> 클래스 => 코드의 비동기 `실행결과`를 주는 클래스
- `Task\<TResult>` 클래스와 달리 `Task` 클래스는 `Action` 델리게이트를 전달받아 결과를 반환하지는 않았다. 이와 달리 `Task\<TResult>` 는 결과를 반환하는데 한번 알아보자
- `Task\<TResult>` 클래스는 결과를 반환하기 때문에 `Func` 델리게이트를 받는다.

<br />

##### Taks\<TResult> 클래스 사용 예제 코드

```csharp
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace TaskResult
{
    class MainApp
    {
        static bool IsPrime(long number)
        {
            if (number < 2)
            {
                return false;
            }

            if (number % 2 == 0 && number != 2)
            {
                return false;
            }

            for (long i = 2; i < number; i++)
            {
                if (number % i == 0)
                {
                    return false;
                }
            }

            return true;
        }

        static void Main(string[] args)
        {
            long from = Convert.ToInt64(args[0]);
            long to = Convert.ToInt64(args[1]);
            int taskCount = Convert.ToInt32(args[2]);

            Func<object , List<long>> FindPrimeFunc = (objRange) =>
            {
                long[] range = (long[])objRange;
                List<long> found = new List<long>();

                for(long i = range[0]; i < range[1]; i++)
                {
                    if (IsPrime(i))
                    {
                        found.Add(i);
                    }
                }
                return found;
            };

            Task<List<long>>[] tasks = new Task<List<long>>[taskCount];
            long currentFrom = from;
            long currentTo = to / tasks.Length;

            for (int i = 0; i < tasks.Length; i++)
            {
                Console.WriteLine("Task[{0}] : {1} ~ {2}", i, currentFrom, currentTo);

                tasks[i] = new Task<List<long>>(FindPrimeFunc, new long[] { currentFrom, currentTo });
                currentFrom = currentTo + 1;

                if(i == tasks.Length - 2)
                {
                    currentTo = to;
                }
                else
                {
                    currentTo = currentTo + (to / tasks.Length);
                }
            }

            Console.WriteLine("Please press enter to start ... ");
            Console.ReadLine();
            Console.WriteLine("Started ...");

            DateTime startTime = DateTime.Now;

            foreach (Task<List<long>> task in tasks)
            {
                task.Start();
            }

            List<long> total = new List<long>();
            
            
            foreach (Task<List<long>> task in tasks)
            {
                task.Wait();
                total.AddRange(task.Result.ToArray());
            }
            
            DateTime endTime = DateTime.Now;

            TimeSpan ellapsed = endTime - startTime;

            Console.WriteLine("Prime number count between {0} and {1} : {2}", from, to, total.Count);

            Console.WriteLine("Ellapsed time : {0}",ellapsed);
        }
    }
}
```

```java
Output 1st

C:\Users\shkim\source\repos\ClassEx\practice1>dotnet run 0 100000 1
Task[0] : 0 ~ 100000
Please press enter to start ...

Started ...
Prime number count between 0 and 100000 : 9592
Ellapsed time : 00:00:03.9273830

Ouput 2nd

C:\Users\shkim\source\repos\ClassEx\practice1>dotnet run 0 100000 5
Task[0] : 0 ~ 20000
Task[1] : 20001 ~ 40000
Task[2] : 40001 ~ 60000
Task[3] : 60001 ~ 80000
Task[4] : 80001 ~ 100000
Please press enter to start ...

Started ...
Prime number count between 0 and 100000 : 9592
Ellapsed time : 00:00:01.3796182
```

- 각각의 Task 별로 소수를 탐색할 범위를 지정해주며 해당 범위내에서 소수의 갯수를 구한다. 

- 입력 : `시작 숫자`, `끝 숫자`, `범위를 몇개로 나눌 것인지`

<br />

### Parallel 클래스 => 병렬처리를 쉽게 하는데에 도움을 주는 클래스

- 이전 `Task\<TResult>` 클래스의 예제에서는 특정 범위 안에 있는 모든 소수를 찾기 위해 여러 개의 `Task` 인스턴스를 생성하여 각 인스턴스에게 작업할 범위를 할당한 후, `foreach` 문을 이용해 시동을 걸었다. 이렇게 시동이 걸린 `Task` 객체들은 동시에 작업을 수행한 뒤 작업 결과를 반환했다. 
- `MicroSoft`에서는 이와 같이 `Task\<TResult>`를 이용해서 직접 구현했던 병렬 처리를 `Parallel` 클래스를 이용해서 더 쉽게 구현할 수 있도록 하였다. 

- `Parallel` 클래스가 메소드를 호출할 때에 몇 개의 스레드를 제공할지는 내부적으로 판단하여 최적화한다. => 사용자가 신경쓰지 않아도 되는듯...?

<br />

#### Parallel 클래스 사용 예제 코드 

```csharp
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace ParallelLoop{
    class MainApp
    {
        static bool IsPrime(long number)
        {
            if (number < 2)
            {
                return false;
            }
            if (number % 2 == 0 && number != 2)
            {
                return false;
            }

            for (long i = 2; i < number; i++)
            {
                if (number % i == 0)
                {
                    return false;
                }
            }

            return true;
        }

        static void Main(string[] args)
        {
            long from = Convert.ToInt64(args[0]);
            long to = Convert.ToInt64(args[1]);

            Console.WriteLine("Please press enter to start ... ");
            Console.ReadLine();
            Console.WriteLine("Started ... ");

            DateTime startTime = DateTime.Now;

            object thisLock = new object();
            List<long> total = new List<long>();

            Parallel.For(from, to, (long i) =>
              {
                if (IsPrime(i))
                  {
                    lock (thisLock) // critical section 제어
                    {
                        total.Add(i);
                    }
                }
              });

            DateTime endTime = DateTime.Now;

            TimeSpan ellapsed = endTime - startTime;

            Console.WriteLine("Prime number count between {0} and {1} : {2} ", from, to , total.Count);

            Console.WriteLine("Ellapsed time : {0}", ellapsed);
        }
    }
}
```
```java
Output

C:\Users\shkim\source\repos\ClassEx\practice1>dotnet run 0 100000
Please press enter to start ...

Started ...
Prime number count between 0 and 100000 : 9592
Ellapsed time : 00:00:00.5171736
```

- 교재에서 제공된 코드와는 다르다. 
- 해당 `total` 리스트에 대해 각각의 스레드들이 서로 원소를 `Add` 함으로써 해당 `Critical Section`에서 에러는 발생하지 않지만 이로인해 실행시 각기 다른 결과가 나왔다. 따라서 해당 `total.Add(i)` 메소드가 호출되는 부분에 `lock` 키워드를 사용해줌으로써 쓰레드가 다중으로 해당 `Critical Section`에 진입하지 못하도록 제어하였다.

- *** readonly 키워드 질문 

<br />

### async 한정자와 await 연산자로 만드는 비동기 코드 

- `async` 한정자 
```csharp
public static async Task MyMethodAsync()
{
    ...
}
```
- 이렇게 `async` 한정자로 메소드나 태스크를 수식하기만 하면 비동기 코드가 만들어진다.
- 다만 `async`로 한정하는 메소드는 반환형식이 `Task`나 `Task\<TResult>`, 또는 `void` 여야만 한다.
- 실행하고 잊어버릴 작업을 담고 있는 메소드라면 반환 형식을 `void` 로 선언하고, 작업이 완료될 때까지 기다리는 메소드라면 `Task`, `Task\<TResult>` 로 선언하면 된다. 
- `async`로 선언한 void 형식의 메소드는 호출 즉시 호출자에게 제어를 돌려준다. => void 메소드는 `async` 키워드 하나만으로 완전한 비동기 코드가 되는 것
- 하지만 `Task`, `Task\<TResult>` 형식의 메소드는 `async` 로 수식하기만 해서는 보통의 동기 코드와 다름없이 동작한다.
- C# 컴파일러는 `Task`, `Task\<TResult>` 형식의 메소드를 `async` 한정자가 수식하는 경우, `await` 연산자가 해당 메소드 내부의 어디에 위치하는지를 찾는다. 이후 `await` 연산자를 찾으면 그곳에서 호출자에게 제어를 돌려주도록 실행 파일을 만든다. => 만일 `await` 연산자를 찾지 못한다면 호출자에게 제어를 돌려주지 않으므로 메소드/태스크는 동기적으로 실행된다.

```csharp
1. async 로 한정한 void 형식 메소든는 awati 연산자가 없어도 비동기로 실행

2. async 로 한정한 Task 또는 Task<TResult> 를 반환하는 메소드/태스크/람다식 은 
   await 연산자를 만나는 곳에서 호출자에게 제어를 돌려주며, 
   await 연산자가 없는 경우 동기로 실행된다.

```

<span align="center">

![async 한정자 & await 연산자가 어떻게 비동기 코드를 형성하는지에 대한 이해도움 이미지](images/async%20%26%20await.PNG)

[async 한정자 & await 연산자가 어떻게 비동기 코드를 형성하는지에 대한 이해도움 이미지]

</span>

- 위 그림에서 `Caller()` 의 실행이 시작되면 ① 의 흐름을 따라 `문장1`이 실행되고, 이어서 ② 의 흐름을 따라 `MyMethodAsync()` 메소드의 실행으로 제어가 이동
- `MyMethodAsync()` 에서는 ③ 을 따라 `문장2`가 실행되고 나면 `async` 람다문을 피연산자로 하는 `await` 연산자를 만나게됨.
- 바로 여기에서 `CLR` 은 ④ 를 따라 제어를 호출자인 `Caller()` 에게로 이동시키고, 위 그림에서 점선으로 표시되어 있는 ⓐ 와 ⓑ 의 흐름을 동시에 실행하게 됨

<br />

#### async 한정자와 await 연산자 사용 예제 코드

```csharp
using System;
using System.Threading.Tasks;

namespace Async
{
    class MainApp
    {
        async static private void MyMethodAsync (int count)
        {
            Console.WriteLine("C"); // 3
            Console.WriteLine("D"); // 4 

            await Task.Run(async () =>
            {
                for (int i = 0; i <= count; i++)
                {
                    Console.WriteLine("{0}/{1} ... ", i, count); // 5, 6, 7 ,8
                    await Task.Delay(100);
                }
            });

            Console.WriteLine("G"); // 11
            Console.WriteLine("H"); // 12
        }

        static void Caller()
        {
            Console.WriteLine("A"); // 1
            Console.WriteLine("B"); // 2

            MyMethodAsync(3); 

            Console.WriteLine("E"); // 9
            Console.WriteLine("F"); // 10
            // => 5,6,7,8 과 9,10 는 거의 동시에 각기 다른 제어에 의해 실행됨 
            // => 이들 6번의 출력은 순서가 섞이거나 뒤바뀔 수 도 있음 
            // => 동시에 각기 다른 스레드에 의해 처리되기 때문
        }

        static void Main(string[] args)
        {
            Caller();

            Console.ReadLine();
            // 프로그램 종료 방지
        }
    }
}
```
```java
Output - 첫번째 시도

A
B
C
D
0/3 ...
E
F
1/3 ...
2/3 ...
3/3 ...
G
H

Output - 두번째 시도

A
B
C
D
E
F
0/3 ...
1/3 ...
2/3 ...
3/3 ...
G
H
```

- `5,6,7,8` 과 `9,10` 는 거의 동시에 각기 다른 제어에 의해 실행됨 
- 이렇게 총 6개의 출력은 순서가 섞이거나 뒤바뀔 수 도 있음 
- 동시에 각기 다른 스레드에 의해 처리되기 때문

<br />

###### Task.Delay() 에 대하여
- `Task.Delay()`가 하는 일은 매개 변수로 입력된 시간 후에 `Task` 객체를 반환하는 것
- 실질적인 역할은 `Thread.Sleep()` 과 동일하나 이 `Task.Delay()`와 `Thread.Sleep()`은 차이가 있음
- `Task.Delay()`는 스레드를 블록시키지 않지만, `Thread.Sleep()`은 전체를 블록시킴
- `UI(User Interface)` 스레드 안에서 `Thread.Sleep()`을 호출하면 `UI`가 `Sleep()`이 반환되기까지 사용자에게 응답하지 못하겠지만, `Task.Delay()`를 사용하면 해당 메소드의 반환 여부와 관계없이 UI가 사용자에게 잘 응답함.

<br />

### .Net 프레임워크가 제공하는 비동기 API 맛보기

#### 동기 코드
```csharp
static long CopySync(string FromPath, string ToPath)
        {
            using (var fromStream = new FileStream(FromPath, FileMode.Open))
            {
                long totalCopied = 0;
                using(var toStream = new FileStream(ToPath, FileMode.Create))
                {
                    byte[] buffer = new byte[1024];
                    int nRead = 0;
                    while((nRead = fromStream.Read(buffer, 0, buffer.Length)) != 0)
                    {
                        toStream.Write(buffer, 0, nRead);
                        totalCopied += nRead;
                    }
                }
                return totalCopied;
            }
        }
```

#### 비동기 코드
```csharp
async Task<long> CopyAsync(string FromPath, string ToPath)
            // async로 한정한 코드를 호출하는 코드도 역시 async로 한정되어 있어야함
            // 반환 형식은 Task 또는 void 형
        {
            using(var fromStream = new FileStream(FromPath, FileMode.Open))
            {
                long totalCopied = 0;

                using(var toStream = new FileStream(ToPath, FileMode.Create))
                {
                    byte[] buffer = new byte[1024];
                    int nRead = 0;
                    while((nRead = await fromStream.ReadAsync(buffer, 0, buffer.Length)) != 0)
                    // ReadAsync()와 WriteAsync() 메소드는 .NET 프레임워크에 async로 한정되어 있음
                    // 이들을 호출하려면 await 연산자가 필요함.
                    {
                        await toStream.WriteAsync(buffer, 0, nRead);
                        totalCopied += nRead;
                    }
                }
                return totalCopied;
            }
        }
```

- 위의 동기 코드와 비동기 코드에 선언된 메소드 둘 사이에는 아무런 기능적 차이가 없다.
- 둘다 똑같이 파일을 복사하고, 복사를 마친뒤에는 파일의 크기를 반환한다.
- 하지만 이 둘을 사용자 인터페이스에서 호출해보면 프로그램의 `응답성`에 큰 차이가 있음을 확인할 수 있다.
- `CopySync()` 메소드(`동기 방식`)의 경우 메소드가 일단 호출되면 실행이 종료될 떄까지 사용자 인터페이스가 사용자에게 거의 응답을 하지 못하는 반면, `CopyAsync()` 메소드(`비동기 방식`)는 실행되는 중간에도 여전히 사용자가 사용자 인터페이스에 접근하는데 아무런 문제가 없다.
- 예제를 통해 확인해보자

#### 비동기 API 사용 예제 코드

```csharp
using System;
using System.IO;
using System.Threading.Tasks;

namespace AsyncFileIO
{
    class MainApp
    {
        // 파일 복사 후 복사한 파일 용량 변환
        static async Task<long> CopyAsync(string FromPath, string ToPath)
        // async로 한정한 코드를 호출하는 코드도 역시 async로 한정되어 있어야함
        // 반환 형식은 Task 또는 void 형
        {
            using (var fromStream = new FileStream(FromPath, FileMode.Open))
            {
                long totalCopied = 0;

                using (var toStream = new FileStream(ToPath, FileMode.Create))
                {
                    byte[] buffer = new byte[1024];
                    int nRead = 0;
                    while ((nRead = await fromStream.ReadAsync(buffer, 0, buffer.Length)) != 0)
                    // ReadAsync()와 WriteAsync() 메소드는 .NET 프레임워크에 async로 한정되어 있음
                    // 이들을 호출하려면 await 연산자가 필요함.
                    {
                        await toStream.WriteAsync(buffer, 0, nRead);
                        totalCopied += nRead;
                    }
                }
                return totalCopied;
            }
        }

        static async void DoCopy(string FromPath, string ToPath)
        {// async로 한정한 코드를 호출하는 코드도 역시 async로 한정되어 있어야함
        // 반환 형식은 Task 또는 void 형
            long totalCopied = await CopyAsync(FromPath, ToPath);
            
            Console.WriteLine("Copied Total {0} Bytes.", totalCopied);
        }

        static void Main(string[] args)
        {
            if (args.Length < 2)
            {
                Console.WriteLine("Usage : AsyncFileIO <Source> <Destination>");
                return;
            }

            DoCopy(args[0], args[1]);

            Console.ReadLine();
        }
    }
}
```
```java
Output

C:\Users\shkim\source\repos\ClassEx\practice1>dotnet run aaa.txt bbb.txt
Copied Total 170980 Bytes.
```