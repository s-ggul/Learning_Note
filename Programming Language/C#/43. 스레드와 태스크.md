## 스레드와 태스크
--------

<br />

- `프로세스(Process)` : 실행파일이 실행되어 메모리에 적재된 인스턴스
- 프로세스는 하나 이상의 `스레드(Thread)`로 구성된다.
- 스레드는 운영체제가 CPU를 할당하는 기본단위이며, 프로세스가 밧줄이라면, 스레드는 밧줄을 이루고 있는 실이라고 할 수 있다.

#### 멀티 스레드(Multi-Thread)를 이용했을때의 장단점.

<br />

##### 장점

1. 사용자 대화형 프로그램에서(콘솔 프로그램과 GUI프로그램 모두) 멀티스레드를 이용하면 응답성을 높일 수 있다는 점을 꼽을 수 있다.
    - 예를 들어 우리가 만든 프로그램을 파일을 복사하는데, 복사할 피일이 너무 커서 소요시간이 30분정도 걸린다고 가정해보자. 이 때 프로그램을 단일 스레드로 만든다면 프로그램이 파일을 복사하는 동안 사용자가 취소 명령을 내리고 싶어도 프로그램이 사용자에게 반응하지 않으므로, 복사를 취소할 수가 없다. 작업관리자를 이용해 강제로 프로세스를 종료시키지 않는 한.. 이 프로그램에 사용자와의 대화를 위한 스레드를 하나 더 추가한다면 파일복사를 하면서도 사용자로부터 명령을 받을 수 있다. 
  
  <br />

2. 멀티 프로세스 방식에 비해 멀티 스레드 방식이 자원공유가 더 쉽다는 점이 있다. 
      - 멀티 프로세스는 GUI가 없는 웹서버같은 서버용 애플리케이션에서 많이 취하는 구조인데, 프로세스끼리 데이터를 교환하려면 소켓이나 공유 메모리 같은 IPC(Inter Process Communication)를 이용해야 한다. 반면 멀티 스레드 방식에서는 그저 스레드끼리 코드 내의 변수를 같이 사용하는 것만으로도 데이터 교환을 할 수 있다. 

<br />

3. 프로세스를 띄우기 위해 메모리와 자원을 할당하는 작업은 (CPU 사용시간등의) 비용이 비싼데, 스레드를 띄울때는 이미 프로세스에 할당된 메모리와 자원을 그대로 사용하므로 메모리와 자원을 할당하는 비용을 지불하지 않아도 된다.

<br />

##### 단점

1. 구현하기가 매우 까다롭다.
2. 테스트하기가 쉽지 않다.
3. 멀티 프로세스 기반의 소프트웨어는 여러 개의 자식프로세스 중 하나에 문제가 생기면 영향이 확산되지 않지만, 멀티 스레드 기반의 소프트웨어에서는 자식 스레드 중 하나에 문제가 생기면 전체에 영향을 미친다.
4. 멀티스레드에서 스레드를 너무 많이 사용하면 오히려 성능이 저하되는 문제가 생길 수 있다.
    - 스레드가 CPU를 사용하기 위해 작업 간 전환(Context Switching)을 해야하는데, 이 작업간 전환이 많은 비용을 소모한다. 많은 스레드가 너무 자주 작업 간 전환을 수행하다 보면 애플리케이션이 실제로 일을 하는 시간에 비해 작업 간 전환에 사용하는 시간이 커지기 때문에 성능이 저하된다.

#### 스레드 시작하기

```csharp
1. Thread의 인스턴스를 생성한다. 이 때 생성자의 매개변수로 스레드가 실행할 메소드를 매개변수로 넘긴다.
2. Thread.Start() 메소드를 호출하여 스레드를 시작한다.
3. Thread.Join() 메소드를 호출하여 스레드가 끝날 때까지 기다린다.
```

```csharp
using System;
using System.Threading;

namespace ThreadEx
{

    class MainApp
    {
        static void DoSomething() // 스레드가 실행할 메소드
        {
            for(int i = 0; i < 5; i++)
            {
                Console.WriteLine($"DoSomething : {i}");
            }
            Thread.Sleep(10); 
            //sleep 메소드는 다른쓰레드도 CPU를 사용할 수 있도록, CPU점유를 내려놓는다. 매개변수는 밀리초 단위이다.
        }

        static void Main(string[] args)
        {
            Thread t1 = new Thread(new ThreadStart(DoSomething)); // Thread의 인스턴스 생성

            Console.WriteLine("Start Threading...");
            t1.Start(); // 스레드 시작

            for(int i = 0; i < 5; i++)
            {
                Console.WriteLine($"Main : {i}");
                Thread.Sleep(10);   
            }

            Console.WriteLine("Wating until thread stops...");
            t1.Join(); // 스레드의 종료 대기

            Console.WriteLine("Finished");
        }
    }
} 
```

```
Output

Start Threading...
Main : 0
DoSomething : 0
DoSomething : 1
DoSomething : 2
DoSomething : 3
DoSomething : 4
Main : 1
Main : 2
Main : 3
Main : 4
Wating until thread stops...
Finished
```

<br />

#### 스레드 임의로 종료시키기.

```csharp

Thread t1 = new Thread(new ThreadStart(DoSomething)); // Thread의 인스턴스 생성

t1.Start();

t1.Abort(); // => 스레드 취소 종료

t1.Join();

```

- `Abort()`메소드는 선언 후 join메소드를 이용해 기다렸다가 합쳐줘야함. Abort()자체적으로 처리 시간을 조금은 염두해야하기에..

- 프로그래머들 사이에서 Abort 메소드의 사용은 `금기시` 되어있기에 `가급적 사용하지 않는것을 추천`한다. => 잘못하면 공유자원이 잠긴채로 쓰레드가 종료되어 다른 스레드에서도 접근하지 못할 수 있음.

``` csharp
using System;
using System.Threading;

namespace ThreadEx
{
    class SideTask
    {
        int count;

        public SideTask(int count)
        {
            this.count = count;
        }

        public void KeepAlive()
        {
            try
            {
                while(count > 0)
                {
                    Console.WriteLine($"{count--} left");
                    Thread.Sleep(10);
                }
                Console.WriteLine("count : 0");
            }
            catch(ThreadAbortException e)
            {
                Console.WriteLine(e);
                Thread.ResetAbort();
            }
            finally
            {
                Console.WriteLine("Clearing resource...");
            }
        }
    }
    class MainApp
    {
        static void Main(string[] args)
        {
            SideTask st = new SideTask(100);
            Thread t1 = new Thread(new ThreadStart(st.KeepAlive));
            t1.IsBackground = false;

            Console.WriteLine("Starting thread ... ");
            t1.Start();

            Thread.Sleep(100);

            Console.WriteLine("Aborting thread ... ");
            t1.Abort();

            Console.WriteLine("Waiting until thread stops ... ");
            t1.Join();

            Console.WriteLine("Finished");
        }
    }
} 
```
```
Output

Starting thread ...
100 left
99 left
98 left
97 left
96 left
95 left
94 left
Aborting thread ...
93 left
Unhandled exception. 92 left
System.PlatformNotSupportedException: Thread abort is not supported on this platform.
   at System.Threading.Thread.Abort()
   at ThreadEx.MainApp.Main(String[] args) in C:\Users\shkim\source\repos\ClassEx\practice1\Program.cs:line 51
91 left
90 left
89 left
88 left
87 left
86 left
85 left
```

- 현재 사용하고 있는 플랫폼에서 지원하지 않는듯함.

```csharp
프로그래머들 사이에서 Abort 메소드의 사용은 `금기시` 되어있기에 `가급적 사용하지 않는것을 추천`한다. 
=> 잘못하면 공유자원이 잠긴채로 쓰레드가 종료되어 다른 스레드에서도 접근하지 못할 수 있음.
```

- 위와 같은 이유 때문에 지원하지 않는 것일지도 모르겠음..

<br />

#### 스레드의 일생과 상태 변화 

|상태|설명|
|:---:|---|
|Unstarted|스레드 객체를 생성한 후 Thread.Start() 메소드가 호출되기 전의 상태|
|Running|스레드가 시작하여 동작중인 상태를 나타냅니다. Unstarted 상태의 스레드를 Thread.Start()메소드를 통해 이 상태로 만들 수 있음|
|Suspended|스레드의 일시 중단 상태를 나타낸다. 스레드를 Thread.Suspend() 메소드를 통해 이 상태로 만들 수 있으며, Suspended상태인 스레드는 Thread.Resume() 메소드를 통해 다시 Running 상태로 만들 수 있음.|
|WaitSleepJoin|스레드가 블록(Block)된 상태를 나타냄. 상태이름이 block이 아닌 WaitSleepJoin인 이유는 스레드에 대해 Monitor.Enter(), Thread.Sleep() 또는 Thread.Join() 메소드를 호출하면 이 상태가 되기 때문.|
|Aborted|스레드가 취소된 상태를 나타낸다. Thread.Abort() 메소드를 호출하면 이 상태가 됨. Aborted 상태가 된 스레드는 다시 Stopped 상태로 전환되어 완전히 중지됨.|
|Stopped|중지된 스레드의 상태를 나타냄. Abort() 메소드를 호출하거나 스레드가 실행중인 메소드가 종료되면 이 상태가 됨.|
|Background|스레드가 백그라운드로 동작하고 있음을 나타냄. Foreground 스레드는 하나라도 살아있는한 프로세스가 죽지 않지만, 백그라운드 프로세스는 스레드가 하나가 아니라 10개가 살아있어도 프로세스가 죽고 사는 것에는 영향을 미치지 않음. 하지만 프로세스가 죽으면 백그라운드 스레드들도 모두 죽음. Thread.IsBackground 속성에 true값을 입력함으로써 스레드를 이상태로 바꿀 수 있음.|

- 이들 ThreadState 열거형의 멤버들은 Flags 어트리뷰트를 가지고 있다. 
- Flags 속성은 자신이 수식하는 열거형을 비트 필드, 즉 플래그 집합으로 처리할 수 있음을 나타냅니다. 
- 스레드는 두가지 이상의 상태를 가질 수 있다. => 이 두가지 이상의 상태를 표현하기 위해 이 Flags 어트리뷰트가 수식되어있는것.

------------>>>>>>>> ~ 571p 까지 진행함.(Flags 및 비트필드부터) <<<<<<<<<----------------

3월 17일까지 590p까지 진행
 
