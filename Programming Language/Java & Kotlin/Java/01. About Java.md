## About Java

---

<br />
   
### Java의 특징

<br />

#### Java의 5가지 핵심 목표

```
1.  객체지향 방법론을 사용해야 한다.
2.  같은 프로그램이 여러 운영체제에서 실행될 수 있어야 한다.
3.  컴퓨터 네트워크 접근기능이 기본으로 탑재되어 있어야 한다.
4.  원격 코드를 안전하게 실행할 수 있어야 한다.
5.  다른 객체 지향 언어들의 좋은 부분만 가지고 와서 사용하기 편해야한다.
```

<br />
   
#### 자동적인 메모리 관리 동작 방식 : `Garbage Collection`(가비지 컬렉션)

- C언어와 `Java`의 가장 큰 차이로 나타나는 부분 => 메모리의 관리를 수행하는 동작 방식

- 간단히 말해 `가비지 컬렉션(GC)`을 통해 개발자는 본인이 직접 메모리를 해제하거나 관리해야하는 부분이 사라진다.

<br />

#### 운영체제의 영향을 받지 않는 실행 : `Virtual Machine`의 장점

- `Java`는 운영체제와는 `독립적인 가상 머신`이라는 구조를 통해서 운영체제와 통신하게 된다.
  - 기본 구조가 이렇다보니 `Java`는 특정한 운영체제에서만 돌아가게 되는 불편함이 사라짐
- 즉, 개발자가 알아야하는 존재는 운영체제뿐이고, 다른 것들에 대해서는 가상 머신이 알아서 해주는 방식 <br /> => 별도로 운영체제를 고려하지 않아도 된다.(플랫폼 혹은 운영체제에 독립적)

  <br />

#### 개발환경

- 필수 : JDK(Java Development Kit) => 개발 도구 키트
- 선택 : IDE(Integrated Development Environment) => 통합 개발 환경 혹은 도구

```
JRE(Java Runtime Environment) => Java의 실행 환경

- 이는 Java로 작성된 프로그램들이 실행될 수 있는 배경이 되는 부분.
- Java를 이용해서 프로그램을 작성하는 개발자들이 아닌 Java로 작성된 프로그램을 사용하는 일반 사용자들에게 필요한 부분.
```

| JDK |
| --- |

        => 개발자에게 필요

| JRE |
| --- |

        => Java 프로그램 실행자에게 필요 => 아래로 JVM까지 포함 = Java Runtime Env

| API |
| --- |

| JVM |
| --- |

  <br />

### Java 프로그램의 실행구조 이해하기

<br />

#### Java의 컴파일러

<br />

- `컴파일러(Compiler)` : 간단히 말하자면 인간이 작성한 언어를 기계어로 번역하는 번역기
- `Java`는 `JVM`이라는 독특한 구조로 되어 있다. 반면 다른 언어는 직접 운영체제와 통신하는 방식을 사용 => 운영체제마다 다른 컴파일러를 사용한다는 의미.
- 즉, `Java`로 작성된 결과물은 운영체제에 종속적인 형태로 만들어지는 것이 아닌 `JVM`만이 인식할 수 있는 언어로 작성됨.
- `Java 컴파일`은 `JVM이 해석할 수 있는 언어`로 만드는 과정

  <br />

#### Java의 해석기

1. 소스파일 작성(.java) => 사용자 작성 => input 입력
2. JVM이 읽을 수 있는 언어로 컴파일 => .java => .class
3. 컴파일된 언어를 해석해서 실행 => output 생성 (`JVM 해석과정`)

  <br />

#### JVM의 해석 단계

1. <b>Load (메모리로 로딩)</b>
   - 파일 시스템에 있는 class파일을 실행하기 위해 메모리로 읽어내는 단계

<br />

2. <b>Verify(검증)</b>
   - 외부에서 들어온 (ex. 네트워크에서 읽어들인 .class) 파일들의 보안 검사를 실행. => 이를 통해 Java언어로는 사용자가 악성코드를 만들어낼 수 없다.
     - 외부에서 들어온 class파일이 바로 사용자의 하드디스크에 접근하는 것을 막음.
   - 이처럼 어떤 class 파일을 실행하려면 반드시 검증과정을 거쳐야 하는데 아무런 조치도 없이 다른 사람의 컴퓨터에서 실행되는 것을 막기 때문에 인터넷의 악성 코드처럼 몰래 실행될 수 없는 구조이다. 이러한 모델을 `Sandbox 보안 모델`이라고 하는데 덕분에 Java언어로는 악성코드의 작성이 불가능하다.
   - 검증 단계에서는 크게 안정성 검사와 더불어 사용자가 작성한 프로그램이 현재 환경에서 실행 가능하도록 메모리 연결이 가능한지에 대한 검사도 진행됨. => 간단히 말해서 실행을 위한 메뉴얼과도 같은것이 작성되는 단계.

<br />

3. <b>Prepare(실행 준비)</b>
   - 본격적인 메모리의 할당. => 검증단계에서 작성한 메뉴얼을 실제로 활용해서 조립하는 단계
   - 작성한 프로그램이 실행할 수 있는 진짜 구조가 만들어지는 단계

<br />

4. <b>Resolve(실행결정)</b>
   - 세밀한 메모리 처리를 담당. => 메모리 영역에 대한 상세조율
   - 메모리 구조상에서 약간의 변경이나 수정 작업을 최종적으로 실행하는 과정

<br />

5. <b>Initialize(초기화) </b>
   - 최종적으로 class파일에서 지정된 클래스 변수를 할당하는 작업을 진행.

  <br />

#### 실행엔진을 통한 실행

- `class파일`이 `ClasssLoader`에 의해서 메모리로 정상적으로 로딩된다면 `Execution Engine(실행엔진)` 은 실행 결정을 함.
  => 실행엔진은 크게 두 가지 방식으로 작동.

  <br />

  1. 그냥 만들어진 class파일들의 코드를 읽어서 해석하는 단순한 역할 => 순수 인터프리터
  2. JIT(Just Int Time) 방식. => 반복적으로 이루어지는 작업에 대해서 반복적인 해석을 피하는 방식

  <br />

  => 이 두 가지 단계를 거치면 인간이 이해할 수 있는 언어가 아닌 기계가 이해할 수 있는 언어로 만들어짐.

  <br />

#### 실행된 후의 메모리를 관리하는 `가비지 컬렉터(Garbage Collector)`

- 효율적인 프로그램을 지속적으로 실행하기 위해서는 메모리 관리가 필수적.
- 기존 C계열 언어에서는 코드를 작성한 개발자들이 직접 메모리관리를 해야했으나, Java에서는 `가비지 컬렉터(Garbage Collector)`가 이를 대신함.

- `가비지 컬렉터(Garbage Collector)` : 말 그대로 쓰레기 수집기 이며, 더는 사용되지 않는다고 판단되는 메모리들을 회수하여 적절한 메모리를 유지할 수 있는 장치.
- `힙(Heap) 메모리 영역` : Java의 데이터가 생성되고 소멸하는 영역

  - ★★★★★(기존 C#을 공부할 적엔 reference타입은 heap영역에 value타입은 stack영역에 저장된다고 공부하였는데 Java에서도 그런지 확인해 볼 것.)

| YOUNG                   | TENURED(GENERATION) | PERM |
| ----------------------- | ------------------- | ---- |
| Eden , Survivor, Spaces |                     |      |

- 위의 표에서 보면 `YOUNG`이라는 영역과 `TENURED(GENERATION)`라는 영역이 보이는데 새로 생긴 데이터는 `YOUNG`이라 불리는 메모리 영역쪽에서 살고 있고, 이곳에 사는 메모리들이 시간이 오래 지나거나 더는 쓸모가 없어지면 `TENURED(GENERATION)` 영역으로 옮겨지게 된다. 가비지 컬렉터는 이 `TENURED(GENERATION)` 영역을 집중적으로 공략한다.
- 맨 오른쪽에 `PERM` 영역은 가비지 컬렉션에 필요한 자원들이 있는 공간 정도로만 생각하자.
- 따라서 다른 언어들과 달리 `Java` 는 이런 메모리의 이동이 자동적이기 때문에 개발자들은 메모리 관리에 신경을 쓰지않고 비즈니스 로직을 처리하는데에만 집중할 수 있다.

  <br />

#### Java 언어의 문법적인 주의 사항 및 환경 설정.

  <br />

##### Java의 키워드

| 분류                                    | 키워드                                                                   |
| --------------------------------------- | ------------------------------------------------------------------------ |
| 소스 파일 구성                          | import, package                                                          |
| 클래스 / 인터페이스 선언, 인스턴스 생성 | class, interface, new                                                    |
| 기본 데이터 형                          | boolean, char, byte, short, int, long, float, double                     |
| 데이터 값                               | true, false, null                                                        |
| 클래스 상속                             | extends, implements                                                      |
| 생성자                                  | super, this                                                              |
| 연산자                                  | instanceof                                                               |
| 접근 제한자                             | public, protected, private                                               |
| 기타 제한자                             | abstract, static, final, native, synchronized(? 얜뭐지?)                 |
| 제어문                                  | if, for, while, do, else, break, continue, default, return, switch, case |
| 에외처리                                | try, catch, finally, throws, throw                                       |
| 기타                                    | goto, transient, volatile, const                                         |

- 이와 같이 이미 `JVM`이나 `JDK` 에서 사용하고 있는 `키워드`들은 사용할 수 없는 단어를 의미한다.

##### 환경 변수의 설정

- Java언어로 프로그램을 작성하는 것은 다음과 같은 세 단계를 거친다.

  <br />

  1. 인간이 볼 수 있는 소스로 작성하는 단계 : .java 확장자로 작성
  2. JVM이 해석할 수 있는 소스로 변환하는 단계 : .class 확장자로 생성
  3. JVM과 JRE를 이용해서 실행하는 단계 : JAVA 해석기가 처리.

  <br />

  => JDK를 설치하면 JVM과 JRE를 더불어서 위의 단계를 처리하는 도구를 가지게 된다고 생각하면 됨.
