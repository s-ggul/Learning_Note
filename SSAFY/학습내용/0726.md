## SSAFY - 2022/07/26 내용 기록

---

<br />

### 이전 내용 요약

<br />

#### 추상(abstract) 클래스

- 추상클래스는 인터페이스보다는 덜 추상화 되어있다. (구현된 메서드가 있어서)
- `abstract 추상키워드` : 선언은 되어있고, 구현이 안되어 있다.(100%는 아님 => 구현되어있을 수도 있음,안될수도 있고)
- `abstract`키워드는 클래스와 메서드에 붙을 수 있다.(변수에는 안됨)
- 선언 형태:

```java
    abstract class 클래스명
    abstract 접근자 ... 메서드명
```

- 추상클래스는 객체생성이 불가능함(단, 타입변수로는 선언이 가능하기에 선언한뒤 자식객체의 인스턴스를 넣어줘도 된다.) => 즉, 혼자 독단적으로 인스턴스화(`new연산자`를 통한)는 안된다.

```java
abstract class P{
	
}

class C extends P{
	
}

public class Test {
	public static void main(String[] args) {
		//P p = new P(); => 객체변수로 선언은 가능하지만 객체생성은 불가능하다.
        P p = new C(); // 추상클래스의 다형성
				
	}
}
```
- 위와 같이 추상클래스를 활용시에는 자식클래스를 이용한다.

- 추상클래스가 추상메서드를 하나이상 포함해야한다는 말은 틀린말이다. (없어도 된다.)
- 즉, 구현된 메서드와 추상메서드를 모두 포함할 수 있다.

```java
abstract class P{
	void call() {}
	abstract void print();
}
```

- 구현이 안된 메서드는 구현이 되지 않았다고 `abstract`키워드를 붙여줘야한다. (안붙이면 에러남..)

- 또 주의할점으로는 추상메서드를 하나라도 가지고 있다면 추상클래스로 선언(`abstract` 키워드가 붙어야한다는 말)되어야 한다. => 앞에서도 말했지만 반대로 추상클래스로 선언되어도 추상메서드가 없어도 된다.

- 추상클래스에서 추상메서드로 선언된 메서드는 상속받는 자식클래스에서 무조건 구현해서 써야한다는 `강제성`을 부여할 수 있다. 만일 상속받은 추상클래스의 추상메서드를 구현하지 않으면 에러가 발생한다.

- 추상메서드에 별도의 접근제한자를 명시하지 않으면 기본적으로 타입은 `default`이다.

- `재정의(overriding)` : 반환타입, 메서드명, 매개변수 모두 같아야한다.

```java
// Calendar c = new Calendar(); // 에러 발생 
		Calendar c = Calendar.getInstance();
```
- `Java API`에 있는 `Calendar` 클래스는 추상클래스이다. 따라서 위와 같이 객체생성이 불가능하다.
- `Calendar` 추상클래스는 내부에 `getInstance()`메서드가 구현(`싱글톤 패턴`)되어 있고, 이를통해 `Calendar`객체를 가져온다. 추상클래스내에 구현되어 있어서이기도 하지만 해당 `getInstance()`메서드는 `Calendar`클래스를 상속받은 자식클래스의 인스턴스를 반환한다. => 즉, `getInstance()`에서 반환되는 객체는 `Calendar클래스 타입의 자식객체`를 반환한다!!!

<br />

---

#### 인터페이스(interface)

- 추상클래스보다 추상화되어있다.(구현된 메서드가 없어서인듯하다. 하지만 `default`메서드를 선언할 수 있다면 추상클래스와 비슷한 형태를 가질 수 있다.)

- 접근제한자를 명시하지 않으면 `public abstract` 키워드가 생략된다.
  - 접근제한자는 다를 수 있다.(부모의 `접근제한자`보다 좁으면 안된다.) => public => protected => default => private
  - 부모의 `예외(Exception)`보다 넓어지면 안된다. 

- 추상클래스와의 가장 큰 차이점으로는 `인터페이스는 다중상속이 가능`하다는 점이다. (추상클래스는 `단일 상속`)

<br />

- 각 상황별로 상속을 받을때 사용하는 키워드가 다르다.

|상황|`클래스`에서 `클래스` 상속| `클래스`에서 `인터페이스` 상속|`인터페이스`에서 `인터페이스` 상속|
|:--:|:--:|:--:|:---:|
|키워드(Keyword)|extends|implements|extends|
|상속 형태|단일 상속|다중 상속 가능|다중 상속 가능|

- `인터페이스 => 인터페이스 상속` 의 경우 인터페이스의 확장이기 때문에 `extends`키워드를 사용한다.

- `인터페이스`와 `추상클래스`의 공통적인 특징으로는 `인터페이스도 추상클래스와 마찬가지로 객체 생성이 안된다`는 점이다. => 즉, `자식클래스(인터페이스를 상속받는)`를 통해서 객체를 생성해야 하며, 해당 `자식클래스`는 `인터페이스`에 있는 `추상메서드`를 꼭 `재정의(override)` 해줘야한다.
  
<br />

- interface 선언 
  - class 정의시 `class`
  - interface 정의시 `interface`
  - annotation(@) 정의시 `@interface`

```java
class A // 클래스
interface A // 인터페이스
@interface A // 어노테이션
```

[참고] : `어노테이션`은 기본적으로 `리플렉션`을 사용해 구현되는데 이는 보안상 좋지한다. `private`으로 선언되어 있어도 해당 변수의 값을 바꿀 수 있다.

<br />

- 선언되는 모든 `변수`는 자동적으로 `public static final` 가 추가된다.
- 선언되는 모든 메서드는 자동으로 `public abstract`이 추가된다.

<br />

- `Java 8 버전` 부터 `default` 와 `static` 메서드가 추가가 되어 조금 더 유연한구조가 가능해지게 되었다.

<br />

#### interface 예제1 코드 

```java
package day0726.inter;

interface Inter01{void a();}
interface Inter02{void b();}
interface Inter03 extends Inter01{
	int SERVER_PORT = 8080;
}
interface Inter04 extends Inter01, Inter02{
	// Java 1.8 버전부터 추가
	default void info() {}
	static void alarm() {}
	
	// 기존 인터페이스에 기능을 추가함에 더욱 편리해졌다.
	// static메서드를 통해 인터페이스들에서 공통으로 정의하는 메서드를 관리하기 더욱 편리해졌다.
}

class InterImpl implements Inter01, Inter02{
	@Override
	public void b() {} 
	// 자식이 메서드를 재정의할때 부모의 제한자 보다 범위가 넓어야한다.
	// 현재 자식메서드의 제한자가 (인터페이스는 기본적으로 public) public 이기 때문에 public 을 붙여 명시해줘야한다. 
	
	@Override
	public void a() {}
}

public class Test {
	public static void main(String[] args) {	
		System.out.println(Inter03.SERVER_PORT);
		// Inter03.SERVER_PORT = 10000; // 에러발생 
		// 변수는 기본적으로 public static final 이기에 에러가 발생한다.
	}
}

```

-  Java 1.8 버전부터 추가
```java
	default void info() {}
	static void alarm() {}
```
- 기존 인터페이스에 기능을 추가함에 더욱 편리해졌다.
- static메서드를 통해 인터페이스들에서 공통으로 정의하는 메서드를 관리하기 더욱 편리해졌다.

```java
class InterImpl implements Inter01, Inter02{
	@Override
	public void b() {} 
```
- 자식이 메서드를 재정의할때 부모의 제한자 보다 범위가 넓어야한다.
- 현재 자식메서드의 제한자가 (인터페이스는 기본적으로 public) public 이기 때문에 public 을 붙여 명시해줘야한다.

```java
public static void main(String[] args) {	
		System.out.println(Inter03.SERVER_PORT);
	    // Inter03.SERVER_PORT = 10000; // 에러발생
    }
```
- 변수는 기본적으로 `public static final` 이기에 에러가 발생한다.

<br />

#### interface 예제2 코드
```java
package day0726.quiz;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

class MyIterator implements Iterator{
	String[] data = {"a", "b", "c"};
	private int pos = data.length;
	private int index = 0;
	
	@Override
	public boolean hasNext() {
		return index < pos;
	}

	@Override
	public Object next() {
		return data[index++];
	}
}

public class Quiz01 {
	public static void main(String[] args) {
		Iterator ite = new MyIterator();
		
		ArrayList<String> list = new ArrayList<>();
		list.add("a");
		list.add("b");
		list.add("c");
		
		while(ite.hasNext()) {
			System.out.println(ite.next());
		}
	}
}
```
```java
Output

a
b
c
```
---

#### Generics

```java
package generic;

class Box01{
	private String data;
	public void setData(String data) {
		this.data = data;
	}
	public String getData() {
		return this.data;
	}
}

class Box02{
	private Object data;
	public void setData(Object data) {
		this.data = data;
	}
	public Object getData() {
		return this.data;
	}
}

public class Test01 {
	public static void main(String[] args) {
		Box01 box = new Box01();
		box.setData("귤");
		System.out.println(box.getData());
		
		Box02 box2 = new Box02();
		box2.setData(100);
		box2.setData("귤");
		String data = (String)box2.getData();
		// 100이 나올수도 있고, 문자열이 나올수도있어 에러가 발생할 여지가 충만하다.
		// 이러한 에러는 실행을 해봐야지만 문제 발생 여부를 알 수 있다.		
	}
}

```
- 100이 나올수도 있고, 문자열이 나올수도있어 에러가 발생할 여지가 충만하다.
- 이러한 에러는 실행을 해봐야지만 문제 발생 여부를 알 수 있다.

<br />

#### Generic `<T>`

- `Generic` => 위의 코드에서와 같이 `Object`를 사용했을때 장점인 여러가지 타입을 하나의 클래스로 적용이 가능하다는 장점을 가져오고, 런타임시에 원하지 않는 타입이 들어온걸 체크해야하고, 값을 추출시에 형변환을 해야만 했던 단점을 극복한 문법이다.

<br />

- `Type Parameter` 로 권장되는 이름들
  - `T` : Type
  - `E` : Eelement => `ArrayList`와 같이 원소가 있는것들
  - `K` : Key
  - `V` : Value

<br />

#### Generic 사용 예제 1 코드

```java
package generic;

class Box03<T>{
	private T data;
	public void setData(T data) {
		this.data = data;
	}
	public T getData() {
		return this.data;
	}
}

public class Test03 {
	public static void main(String[] args) {	
		Box03<String> box3 = new Box03<>();
		box3.setData("귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤\n귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤\n귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤\n귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤\n귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤귤\n");
        //box3.setData(100);
        // 런타임시에 체크되던 부분을 컴파일시에 체크가 되어 미리 실행전에 알 수 있다.
		String data = (String)box3.getData();
		System.out.println(data);
	}
}

```

- 만일 객체생성시 타입을 지정하지 않은 `raw type`으로 선언하면 `T` 타입에 관련한 멤버들은 모두 `Object` 타입으로 변환한다. => 그렇기에 꼭 타입을 명시하자
- 런타임시에 체크되던 부분을 컴파일시에 체크가 되어 미리 실행전에 알 수 있다.

<br />

#### Generic 사용 예제 2 코드
```java
package generic;

class Box04<T, N>{
	private T name;
	private N count;
	
	public Box04(T name, N count) {
		this.name = name;
		this.count = count;
	}

	public T getName() {
		return name;
	}

	public N getCount() {
		return count;
	}
}

public class Test04 {
	public static void main(String[] args) {	
		Box04<String,Integer> box4 = new Box04<String,Integer>("귤",100);
		String name = box4.getName();
		Integer count = box4.getCount();
		System.out.println(name + "이 "+ count+"개!!");
	}
}

```

- 참고로 위와 같이 다중 타입을 받을 수 있지만 제네릭 타입내의 또다른 제네릭 타입이 들어갈 수도 있다.

```java
List<Map<String, List<Integer>>> list = new ArrayList<Map<String, List<Integer>>>();

List<Map<String, List<Integer>>> list = new ArrayList<>();
```

- 위처럼 generic 타입 내부에 또 다른 generic 타입이 들어갈 수 있으며, java 1.7버전 이상부터는 뒤에 객체생성부에 해당하는 곳의 타입을 생략하고 `<>`만 작성해줘도 된다. => 앞의 선언 타입을 통해 추론하여 진행하는 방식 => 둘다 타입을 써주는 것보다는 훨씬 편리하다.
- 즉, 객체 생성시에 타입파라미터 생략이 가능하다는 것이다.

<br />

#### 타입 파라미터 제한
- 필요에 따라서 구체적인 타입으로 제한이 필요한 경우가 있을 수 있다.
- Generic Type 선언시 `특정한 타입`만 받을 수 있도록 제한해 줄 수 있다.

<br />

```java
interface Drink{}

class Coke implements Drink{}
class Sprite implements Drink{}

// T라는 타입파라미터는 Drink 클래스(Drink포함)를 상속받는 모든 타입들을 받고 싶다는 의미.
class IceBox <T extends Drink>{}
```
- `T`라는 타입파라미터는 `Drink 클래스(Drink포함)`를 상속받는 모든 타입들을 받고 싶다는 의미.
- 타입 파라미터 제한에는 `extends` 키워드를 사용한다.

#### 타입 파라미터 제한 예제 코드

```java
package generic;

interface Drink{}

class Coke implements Drink{}
class Sprite implements Drink{}

// T라는 타입파라미터는 Drink 클래스(Drink포함)를 상속받는 모든 타입들을 받고 싶다는 의미.
class IceBox <T extends Drink>{
	
}

interface Burger{}

class CheeseBurger implements Burger {}

class MixBox<T extends Drink & Burger>{}
// 다중 타입제한시에는 `&`를 사용한다.
class BurgerSet implements Drink, Burger{}

public class Test05 {
	public static void main(String[] args) {	
		IceBox<Drink> box = new IceBox<>();// Drink 자신이기 때문에 가능하다.
		//IceBox<String> box2 = new IceBox<>();// 에러 발생 => String은 Drink 클래스를 상속받지 않기에..
		IceBox<Coke> box2 = new IceBox<>();// Coke는 Drink 클래스를 상속받기에 가능하다.	
		MixBox<BurgerSet> box3 = new MixBox<>();
		MixBox<?> box4 = new MixBox<>();
		
	}
}

```
- 다중 타입제한시에는 `&` 를 사용한다.
- 두개의 타입을 모두 받을 수 있다는 의미가 아닌 두개의 타입을 모두 상속받는 객체를 받는다는 의미이다.


#### 와일드카드(wildcard) => `?`
```java
    package generic;

class Box06<T>{
	private T data;

	public T getData() {
		return data;
	}

	public void setData(T data) {
		this.data = data;
	}
	
}

class Fruit{}
class Apple extends Fruit{}
class Grape extends Fruit{}

public class Test06 {
	public static void main(String[] args) {	
		Box06<Fruit> box1 = new Box06<Fruit>();
		Box06<Apple> box2 = new Box06<Apple>();
		Box06<Grape> box3 = new Box06<Grape>();
		
		// 단 아래와 같은 경우는 안됨.
		//Box06<Fruit> box4 = new Box06<Grape>(); // 에러발생
		// 다형성을 생각하고 이렇게 작성하면 안됨.
		
		Box06<? extends Fruit> box5 = new Box06<Grape>();
		// 이렇게 작성하면 다형성을 적용할 수 있다.
	}
}
```
- 단 아래와 같은 경우는 안됨.

```java
Box06<Fruit> box4 = new Box06<Grape>(); // 에러발생
```
- 다형성을 생각하고 이렇게 작성하면 안됨.
- 위와 같이 다형성의 형태로 작성하고 싶다면 아래처럼하면된다.
```java
Box06<? extends Fruit> box5 = new Box06<Grape>();
```
- 이렇게 작성하면 다형성을 적용할 수 있다.
- 또한 자기자신을 포함해 자식까지가 아닌 자기자신을 포함 부모클래스들을 저장하는 제네릭타입도 선언할 수 있다.

```java
Box06<? super Apple> box6 = new Box06<Apple>();
Box06<? super Apple> box7 = new Box06<Fruit>();
Box06<?> box8 = new Box06<Apple>();
Box06<?> box9 = new Box06<Fruit>();
```

- `super`키워드를 통해 상속의 방향이 위로 가는 타입들을 받는 타입도 선언할 수 있고, 단순히 `와일드카드(?)`만 선언하면 모든 타입들을 다 받을 수 있다.

<br />

#### Generic Method
- Generic Method 의 선언

```java
<타입 파라미터> 반환타입 메서드명(타입 파라미터 매개변수, ...)
```

- Generic Method 의 호출

```java
    메서드();
    <타입파라미터>메서드();
    obj.<타입파라미터>메서드();
```

[참고] : 리플렉션의 기초가 되는 단계에 해당하는 메서드 호출

```java
    public <T> Test07(T t) {
		System.out.println("constructor method : " + t.getClass().getName());
	}
	
	public <T> void printTypeInfo(T t) {
		System.out.println("instance method : " + t.getClass().getSimpleName());
	}
```
- `getClass()` 메서드는 `Class객체`를 반환하는데 해당 객체는 `class 정보`를 참조하는데 사용되는 객체이다. 
- 이는 `리플렉션의 기초단계`라고 하셨는데, 차차 알아보자.


```java
package generic;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

public class Test07 {
	public Test07() {}
	public <T> Test07(T t) {
		System.out.println("constructor method : " + t.getClass().getName());
	}
	
	public <T> void printTypeInfo(T t) {
		System.out.println("instance method : " + t.getClass().getSimpleName());
	}
	
	public static <T> void printTypeInfo2(T t) {
		System.out.println("instance method : " + t.getClass().getSimpleName());
	}
	
	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
		list = new LinkedList<>();
		Iterator<String> ite = list.iterator();
		
		
		Test07 t = new Test07();
		Test07 t2 = new Test07(100);
		Test07 t3 = new <Integer>Test07(100);
		
		t3.printTypeInfo("hello");
		t3.<String>printTypeInfo("hello");
		
		Test07.printTypeInfo2('A');
		Test07.<Character>printTypeInfo2('A');
		
	}
}
```
- `static`으로도 선언이 가능하며, 여러가지 호출방식이 존재한다. 잘익혀두자.

<br />

---
<br />

### 예외(Exception)
- 프로그래밍에 있어 `예외`는 두가지로 분류된다.
  - `개발자가 처리하기 힘든 예외(Error)`
  - `처리할 수 있는 예외(Exception)`

- Java에서 `Error 와 Exception 클래스`는 `Throwable`을 상속받는다.

- 컴파일시 발생하는 exception을 `checked exception`, 런타임시 발생하는 exception을 `unchecked exception` 혹은 `Runtime exception` 이라 한다.

<br />

- 컴파일시 발생하는 에러로는..
  - 런타임시 발생하는 exception을 제외한것들.

<br />

- 런타임시 발생하는 대표적인 exception으로는 
  - `NullPointerException`
  - `ArrayIndexOutofBoundException`
  - `ClassCastException`


<br />

#### 에러와 예외
- 어떤 원인에 의해 오동작하거나 비정상적으로 종료되는 경우
- 심각도에 따른 분류
  - Error
    - 메모리부족, stack overflow와 같이 일단 발생하면 복구할 수 없는 상황
    - 프로그램의 비정상적 종료를 막을 수 없음
  - Exception
    - 읽으려는 파일이 없거나 네트워크 연결이 안되는 등 수습될 수 있는 비교적 상태가 약한 것들
    - `프로그램 코드에 의해 수습될 수 있는 상황`

<br />

- exception handling(예외처리)란
  - 예외 발생 시 프로그램의 비정상 종료를 막고 정상적인 실행 상태를 유지하는 것
    - 예외의 감지 및 예외 발생 시 동작할 코드 작성 필요

<br />

#### 예외 관련 키워드

<br />

##### 예외 직접 처리
- try
- catch
- finally

##### 예외 간접 처리
- throws
- throw (=> 예외를 인위적으로 생성할때)

<br />

#### try-catch-finally
- `try{}` : 예외가 발생할만한 코드를 감싸줌. => 즉, 예외와 관련있는 코드를 감싸주는 역할.
- `catch(예외타입 변수명){}` : `try` 블록에서 발생한 예외를 잡아서 어떤 예외를 처리할지 예외타입을 명시한다.
  - 즉, `try` 블럭에서 예외가 발생했을 때 어떤 예외를 처리할지 예외 타입을 선언하고 블럭안에 예외의 처리 구문을 작성한다.
- `finally{}` : 예외발생여부와 상관없이 수행한다. 즉, 무조건 수행한다.

##### 여러가지 형태
- try{} catch(){}
- try{} finally{}
- try{} catch(){} finally{}


#### 예외처리 예제 코드 1
```java
package exception;

import java.io.FileInputStream;

public class Test01 {

	public static void main(String[] args) {
		// Exception in thread "main" java.lang.ArithmeticException: / by zero
		// System.out.println(1/0); // runtime exception
		
		// FileNotFoundException => compile exception
		// System.setIn(new FileInputStream("a.txt")); // checked exception	
	}
}
```

<br />

#### 예외처리 예제 코드 2

```java
package exception;

import java.util.Random;
import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;

public class Test02 {
	public static void main(String[] args) {
		try {
			Scanner sc = new Scanner(new File("a.txt"));
			String line = sc.nextLine();
			System.out.println("읽은 내용 : " + line);
			
			// 랜던값이 0이여서 ArithmeticException이 발생
			// 예외처리 코드가 없어 비정상 종료됨
			System.out.println(1/ new Random().nextInt(2));
			
		}catch(FileNotFoundException e) {
			System.out.println(e.getMessage());
		}finally {
			// 에러가 발생되고 catch에서 못잡더라도 finally 문 실행
			System.out.println("finally : 프로그램 종료");
		}
		System.out.println("프로그램 정상 종료");
	}
}
```

<br />

#### 예외처리 예제 코드 3
```java
package exception;

import java.util.Random;
import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Test03 {
	public static void main(String[] args) throws IOException {
		try {
			FileReader fr = new FileReader("a.txt");
			int line = fr.read();
			System.out.println("읽은 내용 : " + line);

			// 랜던값이 0이여서 ArithmeticException이 발생
			// 예외처리 코드가 없어 비정상 종료됨
			System.out.println(1/ new Random().nextInt(2));

		} 
		// catch 문을 여러개 작성할때는 각 exception 객체 클래스들의 포함여부 및 범위에 따라 점점 커지는식으로 작성되어야 한다. 
		// 즉, 범주가 작은것부터 시작해 점점 큰것으로 점차 범위가 큰 Catch문을 작성해야 올바른 예외처리 동작을 할 수 있게된다. 
		catch(FileNotFoundException e) {
			System.out.println(e.getMessage());
		} 
		catch (IOException ie){
			System.out.println(ie.getMessage());
		} 
		catch (ArithmeticException ae) {
			System.out.println(ae.getMessage());
		} 
		finally {
			// 에러가 발생되고 catch에서 못잡더라도 finally 문 실행
			System.out.println("finally : 프로그램 종료");
		}
		System.out.println("프로그램 정상 종료");
	}
}
```

- 타입이 부모타입으로 선언되어 있으면 자식 예외 객체를 받을 수 있기 때문에 부모 클래스의 예외로 상위 catch문을 처리하면 하위에 있는 해당 부모 예외의 자식 예외를 무시하게 된다. 즉, 예외의 경우 catch 문의 인자로 부모 클래스 타입변수에 자식 인스턴스를 받을 수 있기때문에 상단에서 자식범위로 선언하여 부모 클래스 형으로 점차 커지는 형태로 예외를 처리해야 한다.
- 즉, `catch 문이 여러개일때 부모-자식관계의 예외를 처리한다면!` catch문의 순서에 있어 주의해야한다.
- 위 코드에서 `IOException`이 부모이고, `FileNotFoundException`이 자식 예외임.

<br />

#### 예외처리 예제 코드 4
```java
package exception;

import java.util.Random;
import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Test04 {
	public static void main(String[] args) throws IOException {
		try {
			// 랜던값이 0이여서 ArithmeticException이 발생
			// 예외처리 코드가 없어 비정상 종료됨
			System.out.println(1/ new Random().nextInt(2));
			String s = null;
			System.out.println(s.length());
			
			int[] arr = new int[1];
			System.out.println(arr[1]);
		}  
		catch (ArithmeticException ae) {
			// 특별하게 찝어서 처리하는 예외 
			System.out.println(ae.getMessage());
		} catch (Exception e) {
			// 나머지 예외에 대한 처리도 넣음
			System.out.println(e.getMessage());
		}
		finally {
			// 에러가 발생되고 catch에서 못잡더라도 finally 문 실행
			System.out.println("finally : 프로그램 종료");
		}
		System.out.println("프로그램 정상 종료");
	}
}
```
- 특별하게 딱 찝어서 처리하고자 하는 예외에 대해 먼저 catch문을 정의해두고, 이후 다양한 예외들에 대해서는 위의 코드에서와 같이 `Exception` 타입을 통해 모든 자식 `exception` 자식 객체를 처리하게된다.

<br />

#### 에러 추적 메서드
```java
// 간단한 에러 메세지 확인
System.out.println(e.getMessage());

// 에러의 디버깅을 위한 추적
e.printStackTrace();
```

#### 에러 추적 메서드 사용 예제 코드 5
```java
package exception;

import java.util.Random;
import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

class Err{
	void callA() {
		callB();
	}
	
	void callB() {
		System.out.println(1/0);
	}
}


public class Test04 {
	public static void main(String[] args) throws IOException {
		try {
			Err err = new Err();
			err.callA();
		}  catch (Exception e) {
			// 나머지 예외에 대한 처리도 넣음
			System.out.println(e.getMessage());
			e.printStackTrace();
		}
		finally {
			// 에러가 발생되고 catch에서 못잡더라도 finally 문 실행
			System.out.println("finally : 프로그램 종료");
		}
		System.out.println("프로그램 정상 종료");
	}
}
```
```java
Output

/ by zero
finally : 프로그램 종료
프로그램 정상 종료
java.lang.ArithmeticException: / by zero
	at exception.Err.callB(Test04.java:16)
	at exception.Err.callA(Test04.java:12)
	at exception.Test04.main(Test04.java:25)
```

<br />

#### Multi catch 블록

```java
package exception;


import java.io.FileNotFoundException;
import java.io.FileReader;

public class Test05 {
	public static void main(String[] args) {
		try {
			FileReader fr = new FileReader("a.txt");
			System.out.println(1/0);
		} 
		// 1.7 버전부터 multi catch 가능해짐 
		catch(FileNotFoundException | ArithmeticException ae) {
			System.out.println("예외가 발생하였음");
		} 
//		catch(FileNotFoundException fe) {
//			System.out.println("예외가 발생하였음");
//		} 		
//		catch(ArithmeticException ae) {
//			System.out.println("예외가 발생하였음");
//		} 
		catch (Exception e) {
			System.out.println();
		}
	}
}
```
-위의 코드처럼 처리문이 같다면 `|` 문을 이용해 한번에 여러개의 `exception` 을 처리할 수 있다.(Java 1.7 버전 이상부터)

<br />

#### 예외처리 예제 코드 7
```java
package exception;

public class Test06 {
	public static void main(String[] args) {
		System.out.println(1);
		try {
			System.out.println(21);
			String s = null;
			System.out.println(s.length());
			System.out.println(22);
		}catch(Exception e) {
			System.out.println(3);
			return;
		}finally {
			System.out.println(4);
		}
		System.out.println(5);
	}
}
```
```java
Output

1
21
3
4
```
- `catch` 문에서 `return` 하게 되어도 `finally`는 실행된다.

```java
package exception;

public class Test06 {
	public static void main(String[] args) {
		System.out.println(1);
		try {
			System.out.println(21);
			String s = null;
			System.out.println(s.length());
			System.out.println(22);
		}catch(Exception e) {
			System.out.println(3);
			//return;
			System.exit(0);
		}finally {
			System.out.println(4);
		}
		System.out.println(5);
	}
}
```
- 만일 위와같이 `exit`을 넣게되면 이때에는 즉시 종료하여 `finally`를 실행하지 않는다.

<br />

### 간접처리 
- `throws` => 예외를 스스로 특정위치에서 발생시킬때 사용
- `throw` => 예외를 인위적으로 발생시킨다.
  - `throw 예외객체` 혹은 `throw new 예외객체생성()`형태로 사용한다.


#### 간접처리 예제 코드 1
```java
package exception;

import java.io.FileNotFoundException;
import java.io.FileReader;

public class Test07 {
	static void callOne() { 
		// 예외가 발생하는 위치에서 자신이 직접처리
		try {
			FileReader fr = new FileReader("a.txt");
		} catch (FileNotFoundException fe) {
			fe.printStackTrace();
		}
	}
	
	static void callTwo() throws FileNotFoundException {
		// 예외가 발생한 위치에서 스스로 처리하지 않고, 간접처리를 위해 throws함
			FileReader fr = new FileReader("a.txt");
	}
	
	public static void main(String[] args) {
		//callOne();
		try {
			callTwo();
		}catch(FileNotFoundException fe ) {
			System.out.println(fe.getMessage());
		}
	}
}
```
- `FileReader` 에서는 기본적으로 `throws FileNotFoundException`으로 구현되어있기 때문에 호출해준 곳에서 해당 예외를 처리해야한다.

```java
 public FileReader(String fileName) throws FileNotFoundException {
        super(new FileInputStream(fileName));
    }
```
- `main`문으로 `callTwo()` 를 호출할 때에도 같은 방식으로 예외처리를 진행한다. (대신 직접이던 간접이던 한번 처리해줘야함.)

<br />

#### 간접처리 예제 코드 2
```java
package exception;

import java.io.FileNotFoundException;
import java.io.FileReader;

public class Test08 {
	static void callThree() throws ArithmeticException{
		System.out.println(1/0);
	}
	static void callOne() { 
		// 예외가 발생하는 위치에서 자신이 직접처리
		try {
			FileReader fr = new FileReader("a.txt");
		} catch (FileNotFoundException fe) {
			fe.printStackTrace();
		}
	}
	
	static void callTwo() throws FileNotFoundException {
		// 예외가 발생한 위치에서 스스로 처리하지 않고, 간접처리를 위해 throws함
			FileReader fr = new FileReader("a.txt");
	}
	
	public static void main(String[] args) {
		
		callThree();
		//callOne();
		try {
			callTwo();
		}catch(FileNotFoundException fe ) {
			System.out.println(fe.getMessage());
		}
	}
}
```
- `ArithmeticException`은 런타임 예외이기 때문에 예외처리를 해줘도 되고 안해줘도 된다. 


<br />

#### 간접처리 예제 코드 3
```java
package exception;

import java.io.FileNotFoundException;
import java.io.FileReader;

public class Test08 {
	static void callFour(){
		System.out.println(1/0);
	}
	static void callThree() throws ArithmeticException{
		System.out.println(1/0);
	}
	static void callOne() { 
		// 예외가 발생하는 위치에서 자신이 직접처리
		try {
			FileReader fr = new FileReader("a.txt");
		} catch (FileNotFoundException fe) {
			fe.printStackTrace();
		}
	}
	
	static void callTwo() throws FileNotFoundException {
		// 예외가 발생한 위치에서 스스로 처리하지 않고, 간접처리를 위해 throws함
			FileReader fr = new FileReader("a.txt");
	}
	
	public static void main(String[] args) {
		
		//callThree();
		//callOne();
		try {
			callTwo();
			callFour();
		}catch(Exception e) {
			System.out.println(e.getMessage());
		}
	}
}
```
- `callFour`와 같이 `throws`가 없더라도 호출한 곳으로 예외를 던진다. => 즉, 일단 예외는 던진다는 것이다.
- `throws`는 발생할 수 있는 (던질 수 있는) 예외에 대한 정보를 주기위해 표기한다고 한다.

```java
static void callTwo() throws FileNotFoundException, IOException {
		// 예외가 발생한 위치에서 스스로 처리하지 않고, 간접처리를 위해 throws함
			FileReader fr = new FileReader("a.txt");
			fr.read();
	}
```
- 이렇게 여러개의 예외를 던질수도 있고

```java
static void callTwo() throws Exception {
		// 예외가 발생한 위치에서 스스로 처리하지 않고, 간접처리를 위해 throws함
			FileReader fr = new FileReader("a.txt");
			fr.read();
	}
```
- 큰 범위로 던질 수 있다. 하지만 아래와 같이 주의할 점이 있다.
#### ⚡주의⚡
- 이와 같이 큰 범위로 던지면 받는 쪽에서도 똑같이 큰범위에 대한 `catch`문을 처리해주어야 한다. 따라서 무작정 큰범위를 사용하기 보다는 상황에 맞추어 예외처리를 해주자. 

<br />

#### 간접처리 예제 코드 4
```java
package exception;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Test08 {
	static void callFour(){
		System.out.println(1/0);
	}
	static void callThree() throws ArithmeticException{
		System.out.println(1/0);
	}
	static void callOne() { 
		// 예외가 발생하는 위치에서 자신이 직접처리
		try {
			FileReader fr = new FileReader("a.txt");
		} catch (FileNotFoundException fe) {
			fe.printStackTrace();
		}
	}
	
	static void callTwo() throws IOException {
		// 예외가 발생한 위치에서 스스로 처리하지 않고, 간접처리를 위해 throws함
			FileReader fr = new FileReader("a1.txt");
			fr.read();
	}
	
	public static void main(String[] args) throws IOException {
		// 이렇게 main문에 throws를 해주면 JVM에 내장되어 있는 예외처리를 통해 예외처리를 진행하겠다는 의미가 된다.
		// 알고리즘 문제풀이에서만 사용할 것을 권장한다.
		callTwo();
	}
	
}
```
- 이렇게 main문에 throws를 해주면 JVM에 내장되어 있는 예외처리를 통해 예외처리를 진행하겠다는 의미가 된다.
- 알고리즘 문제풀이에서만 사용할 것을 권장한다.

<br />

#### 간접처리 예제 코드 5 - throw
```java
package exception;

import java.io.FileNotFoundException;
import java.io.FileReader;

class Staff{ // 직접처리와 간접처리를 동시에 사용
	void process() throws FileNotFoundException{
		// 문제발생... 예외
		try {
			FileReader fr = new FileReader("파일...");
		} catch (FileNotFoundException e) {
			System.out.println("직원 문제 처리함...");
			throw e; 
		}
	}
}

class Boss{
	void startWork() {
		Staff staff = new Staff();
		try {
			staff.process();
		} catch (FileNotFoundException e) {
			System.out.println("직원 문제 있음");
		}
	}
}

public class Test08 {

	public static void main(String[] args) {
		Boss boss = new Boss();
		boss.startWork();	
	}
}
```
- 직접처리와 간접처리를 동시에 사용한 케이스이다. 
- 상위 호출자에게도 예외가 발생했음을 알리기위해 사용할 수 있다. 

<br />

#### 간접처리 예제 코드 6 - 사용자 정의 예외
- 예외 클래스를 만드는 방법은 원하는 상위 클래스를 상속받아 구현하면된다. 예제를 확인해보자.
- `class UserException extends Exception` => 컴파일 발생, checkedException
- `class UserException extends RuntimeException` => 런타임(실행시) 발생, uncheckedException

```java
package exception;

import java.util.Scanner;
// class LottoNumberException extends Exception => 이경우는 별도로 예외처리를 진행해주어야함.
class LottoNumberException extends RuntimeException {
	// 런타임은 예외처리가 강제가 아니기에 예외처리를 안해줘도 에러가 안난다. 
	
	// 사용자 정의 예외 클래스도 상세한 메세지를 제공하게 할 수 있다.
	public LottoNumberException() {
		super("로또 번호가 잘못되었습니다. 1 ~ 45 사이로 입력해야 합니다." );
	} // 상위 부모 클래스의 생성자를 이용해 exception message 를 설정할 수 있다.
	
	public LottoNumberException(int num) {
		super("로또 번호가 잘못되었습니다. 1 ~ 45 사이로 입력해야 합니다. 입력 번호 : " + num);
	}
	
}

public class Test10 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("로또 번호를 입력하세요.");
		int num = sc.nextInt();
		try {
			if(num > 45 || num < 1) {
				// 예외 발생시킴
				throw new LottoNumberException(num);
			}
			System.out.println("정상적인 로또 번호가 입력되었습니다.");
		}catch (Exception e) {
			e.printStackTrace();
		}
	}	
}
```
- class LottoNumberException extends Exception => 이경우는 별도로 예외처리를 진행해주어야함.
- 런타임(runtime)은 예외처리가 강제가 아니기에 예외처리를 안해줘도 에러가 안난다.
- 사용자 정의 예외 클래스도 상세한 메세지를 제공하게 할 수 있다.
- 상위 부모 클래스의 생성자를 이용해 exception message 를 설정할 수 있다.
- `RuntimeException`을 상속받는 것을 개발자들이 선호하는 이유는 일반 Exception 보다 유연하기 때문이다.
  - `RuntimeException`이 아니라면 상속과정에 있는 체이닝되어있는 클래스들에 throws를 하면서 예외를 넘겨야하지만 `RuntimeException`은 예외처리가 강제되지 않기에 초기 호출하는 클래스에서 예외처리를 진행해주면 된다. 
  - 그렇기에 유연성이 더 좋고 강제성이 덜해서 개발자들이 선호하는 이유중에 하나이다.

```java
class LottoNumberException extends RuntimeException {
    static String msg = "로또 번호가 잘못되었습니다. 1 ~ 45 사이로 입력해야 합니다.";
	public LottoNumberException() {
		super(msg);
	} 
	public LottoNumberException(int num) {
		super(msg + num);
	}
}
```

#### 알아볼것.
- 위의 코드에서와 같이 RuntimeException 을 상속받은 예외클래스 내에 멤버변수 선언시 `static` 이 붙어야 하는지도 잘 살펴보자.

<br />

#### 자원반납 예제 코드
```java
package exception;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class Test11 {
	public static void main(String[] args) {
		FileReader fr = null;
		BufferedReader br = null;
		FileWriter fw = null;;
		BufferedWriter bw = null;;

		try {
			fr = new FileReader("a.txt");
			br = new BufferedReader(fr);

			fw = new FileWriter("acopy.txt");
			bw = new BufferedWriter(fw);

			// 작업 진행을 하다가 마지막에는 .close()를 통해 닫아줘야함.
		}catch(Exception e) {
			e.printStackTrace();
		}finally {
			if(br != null) {
				try {
					br.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}

			if(fr != null) {
				try {
					fr.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(bw != null) {
				try {
					bw.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if(fw != null) {
				try {
					fw.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}

	}	
}
```
- 초기 `try` 문에서 객체생성시 예외가 발생하면 finally에 왔을때 객체가 null일수 있기때문에 각각의 객체에 해당하는 close 로직에 if문을 추가해줘야한다.
- 위와 같이 작성하게 되면 객체 4개를 생성하고 닫는 코드가 너무 길어진다. => 즉, 1.7버전 이전 개발자들은 위와 같이 코드를 작성하였다.
- 이를 해결하기위해 java 1.7부터는 `AutoCloseable`를 이용해서 자동 close를 활용한다.
- 이를 `try-with-resources block`이라고 한다.
- 아래의 코드를 확인해보자

```java
// 1.7버전 부터는 AutoCloseable을 이용해서 자동 close를 활용한다.
// try-with-resources block
package exception;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

class MyCloseable implements AutoCloseable {
	public void close() {
		System.out.println("MyCloseable - close 호출됨...");
	}
}
public class Test12 {
	public static void main(String[] args) {
		try (
//				MyCloseable mc = new MyCloseable();
				FileReader fr = new FileReader("a.txt");
				BufferedReader br = new BufferedReader(fr);
				FileWriter fw = new FileWriter("acopy.txt");
				BufferedWriter bw = new BufferedWriter(fw);
		) {
			// 작업진행...
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

```
- 1.7버전 부터는 `AutoCloseable`을 이용해서 자동 close를 활용한다.
- `try-with-resources block` => `try(...)`
- `try(...){}` 에서 `try-with-resources`는 `try(...)`에 선언된 객체의 `close()` 메소드를 호출해야한다.
- `try`문 진행중 예외가 발생하던 말던 `try`문이 종료되면 `close()` 메소드를 호출해주고, 이에 따라 `finally`에 `close()`를 명시적으로 호출해줄 필요가 없다.
- 이렇게 `try-with-resources`에서 자동으로 `close`가 호출되는 객체들은 `AutoCloseable`을 상속받아 `close()`를 구현한 객체들만이 해당된다.
- `AutoCloseable`을 구현한 대표적인 형태들로는 `FileReader, BufferedReader, FileWriter, BufferedWriter` 가 있다.


##### DB disconnection의 경우에는?
- 커넥션 풀링을 이용해서 조금 다르다.
-  

<br />
---
