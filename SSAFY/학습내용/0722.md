## SSAFY - 2022/07/22 내용 기록

---
### 다운캐스팅(부모 => 자식)
- Java에서 부모 클래스 형이 자식 클래스형이 되려면 부모 클래스형의 인스턴스가 자시클래스의 객체로 생성된 경우에만 부모형을 명시적으로 형변환을 진행해 자식클래스형으로 기능을 확장할 수 있다.

- 아래의 코드를 확인해보자

```java
Animal a = new Dog();

Dog d = (Dog) a;
```

- 위와 같이 기존 부모형클래스가 자식형의 인스턴스로 생성되어야 `다운캐스팅(부모 => 자식 : 기능의 확장)`을 진행할 수 있다.

---
### 문자열관련

```java
package day0720.array;

public class WaterStrider {

	public static void main(String[] args) {
		
		System.out.println("시간 측정 시작");
		//1970년 1월 1일 0시 0분 0초
		long start = System.currentTimeMillis();
		System.out.println("String");
		String s3 = "";
		for(int i = 0; i < 100000; i++) {
			s3+=i;
		}
		long end = System.currentTimeMillis();
		System.out.println((end-start)/1000d);
		
		System.out.println("StringBuffer");
		long start2 = System.currentTimeMillis();
		StringBuffer s4 = new StringBuffer();
		for(int i = 0; i < 100000; i++) {
			s4.append(i);
		}
		long end2 = System.currentTimeMillis();
		System.out.println((end2-start2)/1000d);
		
		// JVM내에 같은 문자열에 대한 공간은 하나밖에 없음.		
		// 가리키는 공간이 불변
		String s = "나는";
		s+="홍길동";
		s+="입니다.";
		
		String s1 = "A";
		String s2 = "A";
		s2 = "B";
		System.out.println(s1);
		
		// 가리키는 공간이 가변
		StringBuffer sb = new StringBuffer();
		sb.append("나는");
		sb.append("홍길동");
		sb.append("입니다.");
		
		// 가리키는 공간이 가변
		StringBuilder sb2 = new StringBuilder();
		sb2.append("나는");
		sb2.append("홍길동");
		sb2.append("입니다.");				
	}
}
```

- `String`의 경우 `Pool` 이라고 하는 메모리 영역을 `JVM`이 관리한다. `String`으로 선언된 변수들은 같은 문자열이라면 해당문자열을 가리키는 주소가 같다. 하지만 두 변수(`s1, s2`)중 하나에 다른 문자열을 넣으면 해당 주소값에 값을 바꾸는 것이 아닌 `Pool`에 새로운 문자열 저장공간을 확보하고 해당 메모리를 가리킨다. 따라서 서로가 가리키는 값에 대한 변화를 주지 않고, 새로운 문자열이 생길때마다 새로운 메모리 공간을 확보하고 해당 주소를 가리킨다.
- `원래 일반적인 변수의 경우에는 값이 같더라도 저마다의 메모리 공간을 가지고 있으니 헷갈리지 말자.`
- `StringBuffer`와 `StringBuilder`의 경우 객체를 new 하게 되면 클래스가 객체생성될때 메모리 공간을 확보하고 그 안에서 문자열을 쌓아나간다.
- 따라서 단순히 몇번 문자열 연산하는 것이 아니라 문자열에대한 연산이 많이 필요하다면 `StringBuffer` 혹은 `StringBuilder`를 권장한다.

#### concat, append

```java
		String s = "Hello";
		s.concat(" 방가");
		System.out.println(s);
		
		s = s.concat(" 방가"); 
		// concat은 인자로 들어온 문자열을 추가해서 반환하는 형식이기 때문에 새로운 변수에 담아서 하거나 프린트문에  concat을 바로 출력해야한다.
		System.out.println(s);
		
		// StringBuffer 도 마찬가지이다.
		
		StringBuffer sb = new StringBuffer("Hello");
		sb = sb.append(" 방가");
        sb = sb.append(" 방가").append(" 방가");
		System.out.println(sb);
```

- `concat`은 `인자로 들어온 문자열을 추가해서 반환`하는 형식이기 때문에 새로운 변수에 담아서 하거나 혹은 프린트문에  concat을 바로 출력해야한다.
- `StringBuffer`의 `append` 도 마찬가지이다.

#### StringBuilder 와 StringBuffer의 차이점

#### 여러가지 String 메소드 

```java
String s = "Hello Java";
		boolean flag = s.equals("Hello Java");
		System.out.println(flag);
		System.out.println(s.equals("Hello Java"));
		System.out.println(s.equalsIgnoreCase("hello java"));
		
		System.out.println(s.toUpperCase());
		System.out.println(s.toLowerCase());
		
		System.out.println(s.startsWith("Java")); // 사용자 요청이 어떤 자원을 의미하는지 확인할때 
		System.out.println(s.endsWith("Java")); //확장자검사할때 많이 사용됨.
```
```java
Output

true
true
true
HELLO JAVA
hello java
false
true
```

```java
    String s = "Hello Java";
    System.out.println(s.indexOf("a"));
    System.out.println(s.indexOf("a",8));
    System.out.println(s.lastIndexOf("a"));
    System.out.println(s.lastIndexOf("a",8));
    System.out.println(s.substring(2));
    System.out.println(s.substring(2,4));
```
```java
Output

7
9
9
7
llo Java
ll
```
```java
    String s = "Hello Java";
    String[] arr = s.split(" ");   
    System.out.println(Arrays.toString(arr));
```
```java
Output

[Hello, Java]
```

- `split()` 함수의 인자는 정규표현식을 받는다. 정규표현식 기억을 상기해보자.

#### 정규표현식과 replace, replaceAll

#### Random 클래스 상속 test

```java
package day0720.array;

import java.util.Arrays;
import java.util.Random;

class MyRandom extends Random{
    public int nextInt(int bound) {
        return super.nextInt(bound)+1;
    }
}

public class RandomTest {

	public static void main(String[] args) {
		Random r = new Random();
		int no = r.nextInt(45) + 1;
		
		Random r = new MyRandom();
		int no2 = r.nextInt(45);
	}
}
```

- 위의 코드와 같이 `Random`클래스를 상속받아 메소드를 재정의하면 본문에서 매번 1씩 치지 않고도 활용할 수 있다.
- 메소드 원코드를 확인하는 키워드는 `ctrl + 마우스 클릭` 이다.

#### 다양한 출력 방법 
```java
    String name = "박보검";
    int age = 32;
    String msg = "코카콜라 모델이다.";
    String info = "이름 : " + name + "\n나이 : " +age + "세 \n정보 : "+ msg;
    System.out.println(info);
    System.out.printf("이름 : %s\n나이 : %d\n정보 : %s\n",name, age,msg);// 문자열 출력
    String info2 = String.format("이름 : %s\n나이 : %d\n정보 : %s",name, age,msg); // 문자열 반환 
    System.out.println(info2);
```
```java
Output

이름 : 박보검
나이 : 32세 
정보 : 코카콜라 모델이다.
이름 : 박보검
나이 : 32
정보 : 코카콜라 모델이다.
이름 : 박보검
나이 : 32
정보 : 코카콜라 모델이다.
```
- 위와 같이 다양한 출력 방법이 있다. 참고하자.

#### 숫자값을 문자로 
```java
		String str = 100 + "";
		String str2 = String.valueOf(100);
		System.out.println(str);
		System.out.println(str2);
```
```java
Output

100
100
```
- 위와 같이 숫자값을 문자형으로 바꾸는 방법들이 있다. 참고하자.

---
#### 입력 관련
```java
int no = sc.nextInt();
sc.nextLine();
String addr = sc.nextLine();
```

- 만일 사용자가 숫자 1 을 치고 엔터를 누른다면 Java 입력 스트림에는 `1`과 `\n`이 쌓인다. 하지만 `nextInt()`는 숫자 1만 처리하고 만일 이후 입력이 있다면 해당 `줄바뀜(\n)` 문자를 가져오기때문에 `nextLine()`을 이용해 엔터값을 처리해주어야한다.

- 이러한 경우는 `nextInt()` 다음 `nextLine()`으로 입력을 받기 때문에 생긴다.
- 결과적으로 `nextLine()`은 개행문자를 읽을 수 있기 때문에 이러한 용도로도 사용된다.
이러한 상황을 피하기 위해 `nextLine()`만을 사용하거나 `nextInt()`로만 입력받는 경우 등 다양한 경우가 있을것이다.(어차피 `nextInt()`는 정수만 받으니까 개행문자를 읽지 않아 숫자만 가져온다.(스트림으로부터))
---

#### Extract Method

- 함수드래그해서 마우스 우측 클릭 후 refactor => extract method를 통해 함수로 변환할 수 있다.

```java
private int menu() {
		System.out.println("-----------------------");
		System.out.println("1. 전체 조회");
		System.out.println("2. 번호 조회");
		System.out.println("3. 등록");
		System.out.println("4. 수정");
		System.out.println("5. 삭제");
		System.out.println("0. 종료");
		System.out.println("-----------------------");
		System.out.print("메뉴를 선택하세요 : ");
		Scanner sc = new Scanner(System.in);
		int no = Integer.parseInt(sc.nextLine());
		return no;
	}

    //main 메서드

    int no = menu();
```

---
#### DAO, DTO

---
#### 싱글톤(Singleton)
- 생성자를 private으로 막아야함 객체를 더 생성하지 못하게

