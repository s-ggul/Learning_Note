## 0805 내용 기록

---

<br />

### static이 아닌 함수의 인자로 넘기는 것이 더 빠르다.
- 내가 그래프 탐색을 풀이할때 함수의 인자로 board 를 넘기는 개념


### 디버깅 테스트 대비 연습

- SingleTon 기억하기
- `객체 직렬화`


#### 직렬화 관련
```java
package com.ssafy.serial;

import java.util.*;
import java.io.*;

class User implements Serializable, Comparable<User>{
	private String id;
	private String name;
	private String passWord;
	private String sogae;

	public User() {
		super();
	}

	public User(String id, String name, String passWord, String sogae) {
		super();
		this.id = id;
		this.name = name;
		this.passWord = passWord;
		this.sogae = sogae;
	}

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getPassWord() {
		return passWord;
	}

	public void setPassWord(String passWord) {
		this.passWord = passWord;
	}

	public String getSogae() {
		return sogae;
	}

	public void setSogae(String sogae) {
		this.sogae = sogae;
	}

	@Override
	public String toString() {
		return "User [id=" + id + ", name=" + name + ", passWord=" + passWord + ", sogae=" + sogae + "]";
	}

	@Override
	public int compareTo(User o) {
		return this.name.compareTo(o.name);
	}
}

public class Test {
	public static void main(String[] args) {
		List<User> list = new ArrayList<>();
		list.add(new User("hong","홍명보","1111","DF"));
		list.add(new User("kim","김성한","2222","정리맨"));
		list.add(new User("lee","이방원","3333","왕"));

		//파일에 저장하려고 한다. 이러한 정보를 파일에 저장할때 아래와 같이 진행한다.
		//한글이 포함되므로 Writer

		try(
				FileWriter fw = new FileWriter("user.dat");
				){
			Collections.sort(list);
			for(User u : list) {
				fw.write(u.getId()+":"+u.getName()+":"+u.getPassWord()+":"+u.getSogae()+"\n");
				//이와 같이 저장하면 프로젝트밑에 dat파일이 생성된다. 
			}
			System.out.println("파일에 저장되었습니다.");
		}catch(Exception e) {
			e.printStackTrace();
		}
		
		try(
				FileReader fr = new FileReader("user.dat");
				BufferedReader br =new BufferedReader(fr);
				){
			List<User> users = new ArrayList<>();
			while(true) {
				String line = br.readLine();
				if(line == null) {
					break;
				}
				System.out.println(line);
				String[] data = line.split(":");
				users.add(new User(data[0],data[1],data[2],data[3]));
			}
			System.out.println("\n파일에서 읽어온 데이터 객체 확인하기\n");
			for(User u : users) {
				System.out.println(u.getId()+":"+u.getName()+":"+u.getPassWord()+":"+u.getSogae());
				//이와 같이 저장하면 프로젝트밑에 dat파일이 생성된다. 
			}			
		}catch(Exception e) {
			e.printStackTrace();
		}

	}
}

```
- `Collections.sort()`를 list에 대해서 사용하기 위해 `Comparable`을 상속받고 `compareTo()`메서드를 구현한다.
- 직렬화를 진행하지 않고 위와 같이 일일이 문자열에 구분자를 주고 작업을 하게되면 데이터가 커질수록 단점이 많아지고 코드가 복잡해진다.
- `Serialization`이라고 하는 `객체 직렬화`는 이를 더욱 편리하게 작업할 수 있게 해준다. 
  - 이때 사용하는 것으로는 `ObjectInputStream`(파일로부터 내용을 객체로써 읽어들일때), `ObjectOutputStream`(객체 메모리에 작성할때)인데 이를 사용하기 위해서는 해당하는 객체 클래스에 `Serializable` 인터페이스를 `implements`해줘야한다.
  - ObjectWriter와 ObjectReader는 존재하지 않는다. => `byte`단위로 메모리에 작성되기 떄문.

- 아래의 코드를 확인해보자

```java
package com.ssafy.serial;

import java.util.*;
import java.io.*;

public class Test2 {
	public static void main(String[] args) {
		List<User> list = new ArrayList<>();
		list.add(new User("hong","홍명보","1111","DF"));
		list.add(new User("kim","김성한","2222","정리맨"));
		list.add(new User("lee","이방원","3333","왕"));

		try(
				ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("user2.dat"));
				){
			oos.writeObject(list);
			System.out.println("파일에 저장되었습니다.");
		}catch(Exception e) {
			e.printStackTrace();
		}

		try(
				ObjectInputStream ois = new ObjectInputStream(new FileInputStream("user2.dat"));
				){
			@SuppressWarnings("unchecked")
			List<User>users = (List<User>)ois.readObject();
			System.out.println("\n파일에서 읽어온 데이터 객체 확인하기\n");

			for(User u : users) {
				System.out.println(u.getId()+":"+u.getName()+":"+u.getPassWord()+":"+u.getSogae());
				//이와 같이 저장하면 프로젝트밑에 dat파일이 생성된다. 
			}			
		}catch(Exception e) {
			e.printStackTrace();
		}

	}
}
```

- 이전 방식으로 String을 만들어 dat 파일에 저장하고 다시 dat파일을 읽어들여 문자열을 파싱하는 것보다 훨씬 간단하고 보기에도 편하다.
- `Serializable`인터페이스는 내부에 구현할 메서드가 없는데 이렇게 상속은 받아야하지만 구현할 메서드가 없는 인터페이스를 `마킹인터페스`라고 함 => 단순히 체크하는 용도로 사용된다는 의미

#### 주소값 관련 

```java
package com.ssafy.collect;

import java.util.*;
import java.io.*;

class Member{
	String id; 
	String email;
	String addr;
	
	public Member() {
		super();
		// TODO Auto-generated constructor stub
	}
	
	public Member(String id, String email, String addr) {
		super();
		this.id = id;
		this.email = email;
		this.addr = addr;
	}
	
	@Override
	public String toString() {
		return "Member [id=" + id + ", email=" + email + ", addr=" + addr + "]";
	}	
}

public class Test {
	public static void main(String[] args) {
		List<Member> list = new ArrayList<>();
		Member m =new Member("a","a@a.com","ahong");
		list.add(m);
		list.add(new Member("b","b@b.com","bhong"));
		list.add(new Member("c","c@c.com","chong"));
		
		int index = list.indexOf(m);
		int index2 = list.indexOf(new Member("a","a@a.com","ahong"));
		
		System.out.println(index); // 0
		System.out.println(index2); // -1
	}
}
```


- `indexOf`는 객체의 주소값으로 판단한다. => `Object`에 정의되어있던 equals를 사용해서 비교하는 것이다.

```java
package com.ssafy.collect;

import java.util.*;
import java.io.*;

class Member{
	String id; 
	String email;
	String addr;
	
	public Member() {
		super();
		// TODO Auto-generated constructor stub
	}
	
	public Member(String id, String email, String addr) {
		super();
		this.id = id;
		this.email = email;
		this.addr = addr;
	}
	
	@Override
	public String toString() {
		return "Member [id=" + id + ", email=" + email + ", addr=" + addr + "]";
	}	
	
	@Override
	public boolean equals(Object o) {
		return false;
	}
}

public class Test {
	public static void main(String[] args) {
		List<Member> list = new ArrayList<>();
		Member m =new Member("a","a@a.com","ahong");
		list.add(m);
		list.add(new Member("b","b@b.com","bhong"));
		list.add(new Member("c","c@c.com","chong"));
		
		int index = list.indexOf(m);
		int index2 = list.indexOf(new Member("a","a@a.com","ahong"));
		
		System.out.println(index); // -1
		System.out.println(index2); // -1
	}
}

```
- 위처럼 equals를 항상 false를 리턴하도록 재정의해주면 출력 결과가 바뀌게 된다.

```java
package com.ssafy.collect;

import java.util.*;
import java.io.*;

class Member{
	String id; 
	String email;
	String addr;
	
	public Member() {
		super();
		// TODO Auto-generated constructor stub
	}
	
	public Member(String id, String email, String addr) {
		super();
		this.id = id;
		this.email = email;
		this.addr = addr;
	}
	
	@Override
	public String toString() {
		return "Member [id=" + id + ", email=" + email + ", addr=" + addr + "]";
	}	
	
	@Override
	public boolean equals(Object o) {
		if(o == null) return false;
		if(!(o instanceof Member)) return false;
		Member m = (Member) o;
		return this.email.equals(m.email);
	}
}

public class Test {
	public static void main(String[] args) {
		List<Member> list = new ArrayList<>();
		Member m =new Member("a","a@a.com","ahong");
		list.add(m);
		list.add(new Member("b","b@b.com","bhong"));
		list.add(new Member("c","c@c.com","chong"));
		
		int index = list.indexOf(m);
		int index2 = list.indexOf(new Member("a","b@b.com","ahong"));
		
		System.out.println(index); // 0
		System.out.println(index2); // 1
	}
}
```
- 위의 코드는 `equals`를 이메일 속성값을 비교해주는 메서드로 재정의함으로써 `equals`를 이용해 비교하는 메서드들이 email을 비교하여 동작하도록 정의할 수 있다.
- 즉, indexOf는 Object에 정의되어있던 equals를 사용해서 비교하는 것인거고 equals를 재정의해주면 유연하게 사용할 수 있다는 것이다.

```java
package com.ssafy.collect;

import java.util.*;
import java.io.*;

class Member{
	String id; 
	String email;
	String addr;
	
	public Member() {
		super();
		// TODO Auto-generated constructor stub
	}
	
	public Member(String id, String email, String addr) {
		super();
		this.id = id;
		this.email = email;
		this.addr = addr;
	}
	
	@Override
	public String toString() {
		return "Member [id=" + id + ", email=" + email + ", addr=" + addr + "]";
	}	
	
	@Override
	public boolean equals(Object o) {
		if(o == null) return false;
		if(!(o instanceof Member)) return false;
		Member m = (Member) o;
		return this.email.equals(m.email);
	}
	
	@Override
	public int hashCode() {
		return this.email.hashCode();	
	}	
}

public class Test {
	public static void main(String[] args) {
		List<Member> list = new ArrayList<>();
		Member m =new Member("a","a@a.com","ahong");
		list.add(m);
		list.add(new Member("b","b@b.com","bhong"));
		list.add(new Member("c","c@c.com","chong"));
		
		int index = list.indexOf(m);
		int index2 = list.indexOf(new Member("a","b@b.com","ahong"));
		
		System.out.println(index); // 0
		System.out.println(index2); // 1
		
		// -------------------------
		
		Set<Member> set = new HashSet<>();
		Member m1 =new Member("a","a@a.com","ahong");
		set.add(m1);
		set.add(new Member("b","b@b.com","bhong"));
		set.add(new Member("c","c@c.com","chong"));
		
		System.out.println(set.contains(new Member("c","c@c.com","chong"))); // true
		System.out.println(set.contains(m1)); // true
		
	}
}
```

- 위와 같이 Hash 관련자료구조를 이용할때에는 hashCode()도 재정의해줘야한다.
- indexOf와 contains같이 비교에 있어 equals를 사용하는 메서드들이  Object에 정의되어있던 equals를 사용해서 비교하는 것인거고 equals를 재정의해주면 유연하게 사용할 수 있다는 것이다. => hashCode의 경우는 equals만이 아닌 hashCode도 같이 사용하는 자료구조의 경우 재정의해줘야한다.