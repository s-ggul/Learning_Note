## 최단경로 알고리즘

--- 

- 최단 경로 알고리즘은 가장 짧은 경로를 찾는 알고리즘을 의미
- 다양한 문제 상황
  - 한 지점에서 다른 한 지점까지의 최단 경로
  - 한 지점에서 다른 모든 지점까지의 최단 경로
  - 모든 지점에서 다른 모든 지점까지의 최단 경로
- 각 지점은 그래프에서 `노드`로 표현
- 지점 간 연결된 도로는 그래프에서 `간선`으로 표현

<br />

### 다익스트라 알고리즘
- 특정한 노드에서 출발하여 다른 모든 노드로 가능 최단 경로를 계산
- 다익스트라 최단 경로 알고리즘은 음의 간선이 없을때 정상적으로 동작
  - 현실세계의 도로(간선)은 음의 간선으로 표현되지 않음
- 다익스트라 최단 경로 알고리즘은 그리디 알고리즘으로 분류
  - `매 상황에서 가장 비용이 적은 노드를 선택`해 임의의 과정을 반복

#### 동작 과정
1. 출발 노드 선택
2. 최단 거리 테이블 초기화
3. 방문하지 않은 노드 중 최단거리가 가장짧은 노드 선택
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단거리 테이블 갱신
5. 위 과정에서 3번과 4번을 반복


<br />

6:56 : https://www.youtube.com/watch?v=acqm9mM1P6o&t=16s

### BOJ_1916_최소비용 구하기 - 우선순위 큐를 이용한 구현 버전

```java
package day0821;

import java.util.*;
import java.io.*;

public class Main {
	static int N,M;
	static int[] distance;
	static int[][] board;
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		N = Integer.parseInt(br.readLine()); // 도시의 수
		M = Integer.parseInt(br.readLine()); // 간선의 수

		board = new int[N][N];
		for(int i = 0; i < N; i++) {
			Arrays.fill(board[i], Integer.MAX_VALUE);
		}
		distance = new int[N];
		Arrays.fill(distance, Integer.MAX_VALUE);
		StringTokenizer st;

		for(int i = 0; i < M; i++) {
			st = new StringTokenizer(br.readLine());
			int x = Integer.parseInt(st.nextToken())-1;
			int y = Integer.parseInt(st.nextToken())-1;
			int c = Integer.parseInt(st.nextToken());
			if(board[x][y] > c) board[x][y] = c; 
			// 같은 간선에 대한 정보를 여러번 받을 수 있음 => 즉, 간선은 같지만 비용이 다른 경우를 따져야함
		}

		st = new StringTokenizer(br.readLine());
		int start = Integer.parseInt(st.nextToken())-1;
		int end = Integer.parseInt(st.nextToken())-1;

		dijkstra(start);
		
		System.out.println(distance[end]);
	}

	private static void dijkstra(int start) {
		PriorityQueue<Node> pq = new PriorityQueue<>((a,b)-> {
			if(a.d == b.d) return a.num - b.num;
			else return a.d - b.d;
		});

		pq.offer(new Node(start, 0));
		distance[start] = 0;
		while(!pq.isEmpty()) {
			Node cur = pq.poll();
			int num = cur.num;
			int d = cur.d;
			
			if(distance[num] < d) continue; // 현재 기록해놓은 거리가 해당 노드까지의 거리보다 작다면
			
			for(int i = 0; i < N; i++) {
				if(board[num][i] == Integer.MAX_VALUE) continue;
				int cost = d + board[num][i];
				
				if(cost < distance[i]) {
					distance[i] = cost;
					pq.offer(new Node(i, cost));
				}
			}
			
		}
	}

	static class Node{
		int num;
		int d;
		public Node(int num, int d) {
			super();
			this.num = num;
			this.d = d;
		}
	}
}
```

- 우선순위 큐에 넣고,2차원 배열은 가장큰수로 초기화하고, 배열에 비용을 입력하고, 값을 입력받음에 조금 생각하느라 어려웠다. 다익스트라는 조금 더 숙달이 필요할 듯 하다.
- 추가적으로 입력을 받을때 하나의 간선에 대한 정보가 하나만 들어온다고 생각하지 말자. 비용이 다르게 중복되어서 들어올 수 있다. 