## 0804 내용 기록 

---

<br />

### 순열 
- 서로 다른 것들 중 몇개를 뽑아서 한 줄로 나열한 것
- 서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현한다. 

```java
nPr

nPr = n * (n-1) * (n-2) * ... * (n - r + 1)

nPn = n! 이라고 표기하며 Factorial 이라 부른다.

n! = n * (n-1) * (n-2) * ... 2 * 1
```

- 순열의 크기가 고정되어있을땐 반복문으로도 구현할 수 있다.
- 순열의 크기가 고정되어 있지 않다면 재귀로 구현할 수 있다.


#### nPn 의 경우 예제 코드
```java
package day0804;

import java.util.Arrays;
import java.util.Scanner;

public class PermutationTest {

	static int N, totalCount;
	static int[] numbers;
	static boolean[] isSelected;

	// nPn : 1부터 n까지의 수중 n개를 모두 뽑아 순서대로 나열한 것.
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		numbers = new int[N];
		isSelected = new boolean[N+1];	// 수가 1부터 시작해서 인덱스도 1부터 논리적으로 매칭해서 사용

		permutation(0);

	}

	private static void permutation(int cnt){ //cnt : 직전까지 뽑은 순열에 포함된 수의 개수, cnt + 1 번째에 해당하는 순열에 포함될 수를 뽑기
		if(cnt == N) {
			totalCount++;
			System.out.println(Arrays.toString(numbers));
			return;
		}
		
		// 가능한 모든 수에 대해 시도
		for(int i = 1; i<=N; i++) {
			// 시도하는 수가 선택 되었는지 체크
			if(isSelected[i] == true) continue;
			
			// 선택되지 않았다면 수를 사용 
			numbers[cnt] = i;
			isSelected[i] = true;
			
			// 다음수 뽑으러 가기
			permutation(cnt+1);
			
			// 뽑으러 갔다가 돌아오면 사용했던 수에 대한 선택을 되돌려 놓기
			isSelected[i] = false;
		}
	}
}
```
```java
3 // Input

Output

[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]
```

<br />

#### nPr 의 경우 고정된 순열에서 뽑는 경우 예제 코드

```java
package day0804;

import java.util.Arrays;
import java.util.Scanner;

public class PermutationTest {

	static int N, R, totalCount;
	static int[] numbers;
	static boolean[] isSelected;

	// nPn : 1부터 n까지의 수중 n개를 모두 뽑아 순서대로 나열한 것.
	// nPr : 1부터 n까지의 수중 r개를 모두 뽑아 순서대로 나열한 것.(1 <= r <= n)
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		R = sc.nextInt();
		numbers = new int[R];
		isSelected = new boolean[N+1];	// 수가 1부터 시작해서 인덱스도 1부터 논리적으로 매칭해서 사용

		permutation(0);

	}

	private static void permutation(int cnt){ //cnt : 직전까지 뽑은 순열에 포함된 수의 개수, cnt + 1 번째에 해당하는 순열에 포함될 수를 뽑기
		if(cnt == R) {
			totalCount++;
			System.out.println(Arrays.toString(numbers));
			return;
		}
		
		// 가능한 모든 수에 대해 시도
		for(int i = 1; i<=N; i++) {
			// 시도하는 수가 선택 되었는지 체크
			// isSelected를 설정한 시점에는 해당하는 재귀함수 호출만을 돌고 있다.
			if(isSelected[i] == true) continue;
			
			// 선택되지 않았다면 수를 사용 
			numbers[cnt] = i;
			isSelected[i] = true;
			
			// 다음수 뽑으러 가기
			permutation(cnt+1);
			
			// 뽑으러 갔다가 돌아오면 사용했던 수에 대한 선택을 되돌려 놓기
			isSelected[i] = false;
		}
	}
}
```
```java
5 // N
3 // R

Output

[1, 2, 3]
[1, 2, 4]
[1, 2, 5]
[1, 3, 2]
[1, 3, 4]
[1, 3, 5]
[1, 4, 2]
[1, 4, 3]
[1, 4, 5]
[1, 5, 2]
[1, 5, 3]
[1, 5, 4]
[2, 1, 3]
[2, 1, 4]
[2, 1, 5]
[2, 3, 1]
[2, 3, 4]
[2, 3, 5]
[2, 4, 1]
[2, 4, 3]
[2, 4, 5]
[2, 5, 1]
[2, 5, 3]
[2, 5, 4]
[3, 1, 2]
[3, 1, 4]
[3, 1, 5]
[3, 2, 1]
[3, 2, 4]
[3, 2, 5]
[3, 4, 1]
[3, 4, 2]
[3, 4, 5]
[3, 5, 1]
[3, 5, 2]
[3, 5, 4]
[4, 1, 2]
[4, 1, 3]
[4, 1, 5]
[4, 2, 1]
[4, 2, 3]
[4, 2, 5]
[4, 3, 1]
[4, 3, 2]
[4, 3, 5]
[4, 5, 1]
[4, 5, 2]
[4, 5, 3]
[5, 1, 2]
[5, 1, 3]
[5, 1, 4]
[5, 2, 1]
[5, 2, 3]
[5, 2, 4]
[5, 3, 1]
[5, 3, 2]
[5, 3, 4]
[5, 4, 1]
[5, 4, 2]
[5, 4, 3]
```

- 앞서 나온 순열들의 경우 시간복잡도가 `O(n!)` 이기 때문에 보통 n의 값은 11이상 나오는 경우가 거의 없다. 
- 문제를 풀때 이 문제가 순열로 풀이하는 문제가 맞다면 n 의 크기를 보고 잘 결정하자.
- 만일 n의 크기가 11 정도를 넘어간다면 순열로 풀이하는 것이 아닌 다른 아이디어를 생각해보자.

<br />

#### nPr => 입력받은 n 개의 수 중 r개를 뽑는 경우의 수

```java
package day0804;

import java.util.Arrays;
import java.util.Scanner;

public class PermutationTest2 {

	static int N, R, totalCount;
	static int[] numbers, input;
	static boolean[] isSelected;

	// nPn : n개의 입력 받은 수 중 n개를 모두 뽑아 순서대로 나열한 것. (입력받는 수가 1 ~ 100,000)
	// nPr : n개의 입력 받은 수 중 r개를 모두 뽑아 순서대로 나열한 것.(1 <= r <= n)
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		R = sc.nextInt();
		numbers = new int[R];
		input = new int[N];
		isSelected = new boolean[N];	// 수가 1부터 시작해서 인덱스도 1부터 논리적으로 매칭해서 사용

		for(int i = 0; i < N; i++) {
			input[i] = sc.nextInt();
		}
		
		permutation(0);
		System.out.println("총 경우의 수 " + totalCount);

	}

	private static void permutation(int cnt){ //cnt : 직전까지 뽑은 순열에 포함된 수의 개수, cnt + 1 번째에 해당하는 순열에 포함될 수를 뽑기
		if(cnt == R) {
			totalCount++;
			System.out.println(Arrays.toString(numbers));
			return;
		}
		
		// 가능한 모든 수에 대해 시도(input배열의 모든 수 시도)
		for(int i = 0; i < N; i++) {
			// 시도하는 수가 선택 되었는지 체크
			// isSelected를 설정한 시점에는 해당하는 재귀함수 호출만을 돌고 있다.
			if(isSelected[i]) continue;
			
			// 선택되지 않았다면 수를 사용 
			numbers[cnt] = input[i];
			isSelected[i] = true;
			
			// 다음수 뽑으러 가기
			permutation(cnt+1);
			
			// 뽑으러 갔다가 돌아오면 사용했던 수에 대한 선택을 되돌려 놓기
			isSelected[i] = false;
		}
	}
}
```
```java
Output

3 1 
2 4 6
[2]
[4]
[6]
총 경우의 수 3
```

<br />

### 조합(Comblination)

- 조합의 수식

```java

nCr = n! / (n-r)!r! , (n >= r)

nCr = n-1Cr-1 + n-1Cr => 재귀적 표현

nC0 = 1
```

#### 조합 구현 코드

```java
package day0804;

import java.util.Arrays;
import java.util.Scanner;

public class CombinationTest {
	
	static int N, R, totalCnt;
	static int[] numbers, input;
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		R = sc.nextInt();
		totalCnt = 0;
		
		input = new int[N];
		numbers = new int[R];
		
		for(int i = 0; i < N; i++) {
			input[i] = sc.nextInt();
		}
		
		combination(0, 0);
		
		System.out.println("총 경우의 수 : " + totalCnt);
		
	}
	
	private static void combination(int cnt, int start) {
		if (cnt == R) {
			totalCnt++;
			System.out.println(Arrays.toString(numbers));
			return;
		}else {
			// 가능한 모든 수에 대해 시도(input 배열의 가능한 수 시도)
			
			// start 부터 처리시 중복 수 추출 방지 및 순서가 다른 조합 추출 방지
			
			for(int i = start; i < N; i++) {
				// start 위치부터 처리했으므로 중복체크 필요없음!!!
				
				// 앞쪽에서 선택되지 않았다면 수를 사용
				numbers[cnt] = input[i];
				// 다음수 뽑으러 가기
				combination(cnt+1, i+1);
				
			}
		}
	}
}
```

```java
Input

3 2
2 4 6

Output

[2, 4]
[2, 6]
[4, 6]
총 경우의 수 : 3
```