## 0810 내용기록

---

<br />

#### 정사각방 관련

- 기존 모든 칸을 탐색하며 해당하는 칸에 대한 bfs를 진행하기는 무리가 있다.
  - 난 이렇게 풀었다... 
  - 위의 경우 최악의 경우로 모든 칸이 연결되어 있을때 1억번 이상의 연산을 하게되고 , 시간초과가 날 것이다.


- `교수님 해설`
  - 카운팅 배열을 하나 선언한다.
  - 한 칸에서 사방탐색을 통해 나보다 1 큰 놈이 있다면 그 수를 카운팅 배열 인덱스에 기록한다.
  - 위와 같은 방식으로 `board`를 탐색하고, 카운팅배열에 기록한 후 나중에 카운팅배열을 탐색했을때 연속적으로 1이 나온 경우를 탐색하면 된다. 이 경우 1을 더해주어야 하는데 이는 마지막 1이 등잔한 후 다음칸으로 넘어가는 경우를 세 준 값이다. 따라서 이처럼 `카운팅 배열을 별도`로 선언하고 활용하여 시간복잡도를 현저히 줄일 수 있다.
  - 또한 1이 시작하는 인덱스와 끝나는 인덱스간의 관계는 해당하는 인덱스와 count 값을 `-` 혹은 `+` 연산하여 구할 수 있다.

```java
import java.io.FileInputStream;
import java.util.Scanner;

class SWEA_D4_1861_정사각형방 {
	static int[][] map;
	static int[] check;
	public static void main(String[] args) throws Exception {
		System.setIn(new FileInputStream("data/swea_1861.txt"));
		Scanner sc = new Scanner(System.in);
		for (int t = 1, T = sc.nextInt(); t <= T; t++) {
			int N = sc.nextInt();
			map = new int[N][N];
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < N; j++) {
					map[i][j] = sc.nextInt();
				}
			}
			check = new int[N * N + 1];
			int[] dx = {0, 0, 1, -1};
			int[] dy = {1, -1, 0, 0};
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < N; j++) {
					for (int d = 0; d < 4; d++) {
						int nx = i + dx[d],
						    ny = j + dy[d];
						if (nx < 0 || nx >= N || ny < 0 || ny >= N) continue;
						if (map[i][j] + 1 == map[nx][ny]) {
							check[map[i][j]]++;
							break;
						}
					}
				}
			}
			
			int minRoom = 1000, maxMove = 0;
			int move = 1;
			for (int i = N * N; i > 0; i--) {
				if (check[i] == 0) {
					move = 1;
					continue;
				}
				move++;
				if (maxMove <= move) {
					maxMove = move;
					minRoom = i;
				}
			}
			
			System.out.printf("#%d %d %d%n", t, minRoom, maxMove);
		}
	}
}
```

- 결국 check배열을 뒤에서부터 탐색하기 때문에 최대 이동값이 같은 경우 낮은 번호를 택함에 있어서도 올바른 값을 낸다.

- `추가` : 또다른 방법도 있다.
  - 초기 2차원 배열을 선언한다. 이때 첫번째 행에는 각 인덱스에 따른 좌표를 저장하고, 그 밑에는 1을 입력한다. 이후 해당 2차원 배열을 탐색하며 해당 인덱스에 대한 사방탐색을 진행하고, 만일 해당 인덱스보다 1 작은값이 존재하는 경우엔 해당 2차원 배열에 저장된 값을 자신에게 더해준다. 이 방식보다는 전자가 나았지만 그래도 기억하자.


### 배열 돌리기1 - 교수님 풀이

```java

```

- 구현은 비슷했지만 과도한 연산을 포함한 반복을 진행하다보니 뭔가 실행시간이 느린것 같다.. 
- 또한 문제 조건을 통해 충분히 생각해보자. 무조건 빨리 푸는것보다 적당한 시간내에 푸는것또한 중요하다.

### 다리놓기 

- 초기 교수님께서 주신 Combination 식이 없었으면 풀기 어려웠음 
- ~n~C~r~ = ~n-1~C~r-1~ + ~n-1~C~r~ : 이 식은 외워놔도 좋을듯함
- 이 식은 풀어서 검증을 완료하였으며, 또한 증명도 했다. 

<br />

#### 식 유도

1. ~n~C~r~ : n개중 r개를 뽑음

2. ~n-1~C~r-1~ : n-1개중 r-1개를 뽑음 => 즉, n-1개중에서 r-1개를 뽑았으므로, 이후 마지막 n에서는 해당 n을 한번 뽑아줘야하는 경우 => 다시말해 마지막 하나 빼고 모두 뽑은 경우

3. ~n-1~C~r~ : n-1개중 r개를 뽑음 => 즉, n-1개중에서 r개를 모두 뽑았으므로, 이후 마지막 n에 대해 뽑지않아도 됨을 의미 => 다시말해 마지막에 뽑을 필요없이 이미 모두 뽑은 경우

=> 따라서 n개중 r개를 뽑는 경우는 2번과 3번을 모두 더한 경우임에 자명하다.

<br />

#### 교수님 코드

```java

```

- 교수님께서는 재귀를 사용한 Top Down 방식으로 구현하셨다. 
- 간혹 재귀를 사용할 시 콜스택이 터질수도 있으니 조심하자.

<br />

