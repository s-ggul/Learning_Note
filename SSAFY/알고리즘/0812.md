## 0812 내용기록
---

<br />

### BOJ_2961 도영이가 만든 맛있는 음식 - 교수님 풀이

```java
package day0812;

import java.util.Scanner;

public class BOJ_2961_도만맛 {
	static int[][] data;
	static int n, ans;
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		n = sc.nextInt();
		data = new int[n][2];
		ans = Integer.MAX_VALUE; // 가장 큰값 설정
		// ans = 1 << 30;
		// ans = (int)1e9;
		// ans = 987654321;
		
		for(int i = 0; i < n; i++) {
			data[i][0] = sc.nextInt();
			data[i][1] = sc.nextInt();
		}
		
		food(0,1,0);
		
		System.err.println(ans);
		
		sc.close();
	}
	
	private static void food(int cnt, int s, int b) {
		if(cnt == n) {
			int val = Math.abs(s-b);
			if(ans > val && b != 0) ans = val;
			return;
		}
		
		
		food(cnt+1, s*data[cnt][0], b+data[cnt][1]);
		food(cnt+1, s, b);
	}
}
```
- 실로 경이롭다
- 부분집합 코드를 응용한 경우이다.

<br />

### 우선순위 큐 - Priority Queue
- 교수님의 추가적인 우선순위 큐 관련 세션이 있었다.

``` java
package day0812;

import java.util.Comparator;
import java.util.PriorityQueue;

public class PQTest {
	
	public static void main(String[] args) {
		System.out.println("-----Max Heap-----");
		PriorityQueue<Integer> pq = new PriorityQueue<>();		// 기본적으로 minHeap으로 구현되어 있다.
		// 우선 순위 큐
		
		pq.offer(2);
		pq.offer(1);
		pq.offer(-8);
		pq.offer(-9);
		pq.offer(9);
		pq.offer(4);
		
		System.out.print(pq.poll() + " ");
		System.out.print(pq.poll() + " ");
		System.out.print(pq.poll() + " ");
		System.out.print(pq.poll() + " ");
		System.out.print(pq.poll() + " ");
		System.out.print(pq.poll() + " ");
		System.out.print(pq.poll() + " "); // 없는데 하나 더 꺼내보기
		
		System.out.println("\n\n-----Max Heap : 람다식-----");
		
		PriorityQueue<Integer> pq2 = new PriorityQueue<>((a,b) -> b-a);
		
		pq2.offer(2);
		pq2.offer(1);
		pq2.offer(-8);
		pq2.offer(-9);
		pq2.offer(9);
		pq2.offer(4);
		
		System.out.print(pq2.poll() + " ");
		System.out.print(pq2.poll() + " ");
		System.out.print(pq2.poll() + " ");
		System.out.print(pq2.poll() + " ");
		System.out.print(pq2.poll() + " ");
		System.out.print(pq2.poll() + " ");
		System.out.print(pq2.poll() + " "); // 없는데 하나 더 꺼내보기
		
		System.out.println("\n\n-----Max Heap : 익명클래스 -----");
		
		PriorityQueue<Integer> pq3 = new PriorityQueue<>(new Comparator<Integer>() {
			@Override
			public int compare(Integer o1, Integer o2) {
				return o2-o1;
			}
		});
		
		pq3.offer(2);
		pq3.offer(1);
		pq3.offer(-8);
		pq3.offer(-9);
		pq3.offer(9);
		pq3.offer(4);
		
		System.out.print(pq3.poll() + " ");
		System.out.print(pq3.poll() + " ");
		System.out.print(pq3.poll() + " ");
		System.out.print(pq3.poll() + " ");
		System.out.print(pq3.poll() + " ");
		System.out.print(pq3.poll() + " ");
		System.out.print(pq3.poll() + " "); // 없는데 하나 더 꺼내보기
		
		System.out.println("\n\n----- Student 형을 가지는 우선순위 큐 구현 -----");
		System.out.println("----- 오름차순 -----");
		PriorityQueue<Student> pq4 = new PriorityQueue<>();
		pq4.offer(new Student(10,"서예지"));
		pq4.offer(new Student(20,"조재형"));
		pq4.offer(new Student(30,"김민식"));
		pq4.offer(new Student(40,"안효관"));
		
		System.out.println(pq4.poll());
		System.out.println(pq4.poll());
		System.out.println(pq4.poll());
		System.out.println(pq4.poll());
		
		System.out.println("\n----- 내림차순 -----");
		PriorityQueue<Student> pq5 = new PriorityQueue<>((a,b) -> b.no-a.no);
		pq5.offer(new Student(10,"서예지"));
		pq5.offer(new Student(20,"조재형"));
		pq5.offer(new Student(30,"김민식"));
		pq5.offer(new Student(40,"안효관"));
		
		System.out.println(pq5.poll());
		System.out.println(pq5.poll());
		System.out.println(pq5.poll());
		System.out.println(pq5.poll());
	}
	
	static class Student implements Comparable<Student>{
		int no;
		String name;
		Student(int no, String name){
			this.no = no;
			this.name = name;
		}
		
		@Override
		public int compareTo(Student o) {
			return this.no - o.no;
		}
		
		@Override
		public String toString() {
			return "Student [no=" + no + ", name=" + name + "]";
		}
	}
}
```

- `우선순위큐(Priority Queue)` 는 기본적으로 minHeap으로 구현되어 있다.

<br />

#### Priority Queue 구현1 - 단순 기능 구현

```java
package day0812;

import java.util.Arrays;

public class PQ1 {
	int[] elements;
	int pos;	
	
	public PQ1() {
		elements = new int[10 + 1];// 루트 값을 1부터 가기위해서 1더 더해줌 => 0번째는 안씀
	}

	public boolean isFull() {
		return pos == elements.length-1;
	}
	
	public void offer(int data) {
		if(isFull()) {
			increase();
		}
		
		elements[++pos] = data;
		
		// 위쪽의 부모와 비교하며 자리를 바꿔줘야함
		int idx = pos;
		
		while(idx > 1 && isSwap(idx/2,idx)) {
			// 조건에 맞으면 스왑
			swap(idx/2, idx);
			idx /= 2;
		}
	}
	
	public void swap(int p, int c) {
		int temp = elements[p];
		elements[p] = elements[c];
		elements[c] = temp;
	}
	
	public void increase() {
		elements = Arrays.copyOf(elements, elements.length * 2);
	}
	
	public int poll() {
		if(pos == 0) return 0;
		
		int result = elements[1]; // 루트
		elements[1] = elements[pos];
		elements[pos--] = 0;
		
		heapify();
		
		return result;
	}
	
	public void heapify() {
		int idx = 1;
		while(idx * 2 <= pos) {
			if(pos >= idx * 2 + 1) { // 자식이 양쪽 다 있는 경우
				if(!(isSwap(idx,idx*2) && isSwap(idx,idx*2+1)))	break;			
			}
			else { // 한쪽만 자식이 있는 경우
				if(!isSwap(idx,idx*2)) break;
			}
			
			int changeIdx = idx * 2;
			
			if(pos >= idx * 2 + 1) {
				changeIdx = isSwap(idx * 2, idx * 2 + 1) ? idx * 2 + 1: idx * 2;
			}
			
			swap(idx, changeIdx);
			idx = changeIdx;
		}
		
	}
	
	public boolean isSwap(int p, int c) {
		return elements[p] > elements[c];
	}
	
	@Override
	public String toString() {
		if(pos == 0) return "[]";
		StringBuilder sb = new StringBuilder("[");
		
		sb.append(elements[1]);
		if(pos==1) return sb.append("]").toString();
		
		for(int i = 2; i<= pos; i++) {
			sb.append(","+elements[i]);
		}
		
		return sb.append("]").toString();
	}
}

```

#### Priority Queue 구현2 - Comparator 구현

-PQTest2
```java
package day0812;

import java.util.Comparator;
import java.util.PriorityQueue;

public class PQTest2 {
	public static void main(String[] args) {
		PQ2 pq = new PQ2();		
		pq = new PQ2(new Comparator<Integer>() {
			 @Override
			 public int compare(Integer n1, Integer n2) {
				 return n2 - n1;
			 }
		});
		
		pq = new PQ2((a,b)->b-a);
		
		pq.offer(2);
		pq.offer(1);
		pq.offer(-8);
		pq.offer(-9);
		pq.offer(9);
		pq.offer(4);
		
		System.out.print(pq.poll() + " ");
		System.out.print(pq.poll() + " ");
		System.out.print(pq.poll() + " ");
		System.out.print(pq.poll() + " ");
		System.out.print(pq.poll() + " ");
		System.out.print(pq.poll() + " "); 
	}
}
```

- PQ2
```java
package day0812;

import java.util.Arrays;
import java.util.Comparator;

public class PQ2 {
	int[] elements;
	int pos;	
	Comparator<Integer> comparator;
	
	public PQ2() {
		elements = new int[10 + 1];// 루트 값을 1부터 가기위해서 1더 더해줌 => 0번째는 안씀
	}

	public PQ2(Comparator<Integer> comparator) {
		this();
		this.comparator = comparator;
	}
	
	public boolean isFull() {
		return pos == elements.length-1;
	}
	
	public void offer(int data) {
		if(isFull()) {
			increase();
		}
		
		elements[++pos] = data;
		
		// 위쪽의 부모와 비교하며 자리를 바꿔줘야함
		int idx = pos;
		
		while(idx > 1 && isSwap(idx/2,idx)) {
			// 조건에 맞으면 스왑
			swap(idx/2, idx);
			idx /= 2;
		}
	}
	
	public void swap(int p, int c) {
		int temp = elements[p];
		elements[p] = elements[c];
		elements[c] = temp;
	}
	
	public void increase() {
		elements = Arrays.copyOf(elements, elements.length * 2);
	}
	
	public int poll() {
		if(pos == 0) return 0;
		
		int result = elements[1]; // 루트
		elements[1] = elements[pos];
		elements[pos--] = 0;
		
		heapify();
		
		return result;
	}
	
	public void heapify() {
		int idx = 1;
		while(idx * 2 <= pos) {
			if(pos >= idx * 2 + 1) { // 자식이 양쪽 다 있는 경우
				if(!(isSwap(idx,idx*2) && isSwap(idx,idx*2+1)))	break;			
			}
			else { // 한쪽만 자식이 있는 경우
				if(!isSwap(idx,idx*2)) break;
			}
			
			int changeIdx = idx * 2;
			
			if(pos >= idx * 2 + 1) {
				changeIdx = isSwap(idx * 2, idx * 2 + 1) ? idx * 2 + 1: idx * 2;
			}
			
			swap(idx, changeIdx);
			idx = changeIdx;
		}
		
	}
	
	public boolean isSwap(int p, int c) { // 정렬의 기준을 잡은 곳=> comparator를 이용해 재구현
		if(comparator != null) {
			return comparator.compare(elements[p], elements[c]) > 0;
		}
		return elements[p] > elements[c];
	}
	
	@Override
	public String toString() {
		if(pos == 0) return "[]";
		StringBuilder sb = new StringBuilder("[");
		
		sb.append(elements[1]);
		if(pos==1) return sb.append("]").toString();
		
		for(int i = 2; i<= pos; i++) {
			sb.append(","+elements[i]);
		}
		
		return sb.append("]").toString();
	}
}
```

- comparator를 받는 생성자를 생성하고, 해당 comparator를 가지고 정렬의 기준으로 사용한다.
- 이때 기존 구현한 코드에서 정렬의 기준을 세우는 곳은 `isSwap()` 메서드로 `isSwap()` 내에서 comparator 인스턴스가 있는지 검사한 후 해당 인스턴스의 compare를 사용하여 반환 값이 양수인 경우에는 true를 반환할 수 있도록 한다.
- 만일 comparator 인스턴스가 없다면 기존처럼 minHeap구조대로 비교하여 반환한다.

<br />

#### 탈주범 검거 기가막힌 유경씨 코드

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class SWEA_1953 {
	public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	public static StringTokenizer st;
	public static StringBuilder sb = new StringBuilder();
	public static int[] dr = {-1, 0, 1, 0};	
	public static int[] dc = {0, 1, 0, -1};
	public static int[] dst = {0, 15, 5, 10, 3, 6, 12, 9};
	
	public static int N, M, R, C, L;
	public static int[][] arr;
	public static boolean[][] cnt;
	
	public static void main(String[] args) throws Exception {
		
		int T = Integer.parseInt(br.readLine());
		
		for(int t=1; t<=T; t++) {
			sb.append("#"+t+" ");
			
			st = new StringTokenizer(br.readLine());
			N = Integer.parseInt(st.nextToken());
			M = Integer.parseInt(st.nextToken());
			R = Integer.parseInt(st.nextToken());
			C = Integer.parseInt(st.nextToken());
			L = Integer.parseInt(st.nextToken());
			arr = new int[N+2][M+2];
			cnt = new boolean[N+2][M+2];

			for(int n=0; n<N; n++) {
				st = new StringTokenizer(br.readLine());
				for(int m=0; m<M; m++) {
					arr[n+1][m+1] = Integer.parseInt(st.nextToken());
				}
			}
			cnt[R+1][C+1] = true;
			sb.append(bfs()+"\n");
		}
		
		System.out.println(sb);
	}

	private static int bfs() {
		int result = 0;
		Queue<int[]> queue = new LinkedList<>();
		queue.add(new int[]{R+1, C+1, 0});
		
		while(!queue.isEmpty()) {
			int[] data = queue.poll();
			if(data[2]==L) break;
			
			result++;
			int d = arr[data[0]][data[1]];
			
			for(int i=0; i<4; i++) {
				if((dst[d] & 1<<i)!=0) { // 1 
					int r = data[0] + dr[i];
					int c = data[1] + dc[i];
					if(cnt[r][c]) continue;
					if((dst[arr[r][c]] & 1<<((i+2)%4))==0) continue; // 2 
					cnt[r][c] = true;
					queue.add(new int[] {r, c, data[2]+1});
				}
			}
		}

		return result;
	}
}
```

- 기존 static 으로 방향을 상좌하우로 한것같다.
- 이후 1번에서 dst[d]를 통해 현재 번호의 파이프를 가져와 해당 파이에서 이동할 수 있는 경로인지 체크하고, 이후 2번에서 다음 장소의 파이프가 이전 번호의 파이프와 맞닿아 있는지 체크한다. 
- 위에 주석으로 표시한 1번과 2번 라인은 실로 어마무시한 코드인 것 같다.