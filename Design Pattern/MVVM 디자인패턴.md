#### MVVM 디자인 패턴

---

```markdown
`Model` - 데이터를 처리하는 기본 단위로 데이터 클래스를 뜻함, 사용자에게 보여주고자 하는 정보
`View` - 사용자가 보고, 입출력하는 화면으로 Xaml 파일을 뜻함
`View Model` - View의 추상화 클래스로 비즈니스 로직이 구현되어 있음.
```

- `MVVM` 패턴은 `WPF(Windows Presentation Foundation)`에서 주로 사용.

- `View`에는 `Control`이라는 `Component`의 집합이 있다. => 즉, 여기서 `Control`은 `Controller`가 아닌 화면 UI에 출력되는 `Component`들의 집합 => `user` 입장에서의 `Control`

- 코드 비하인드는 이러한 컴포넌트들이 구성된 코드를 말한다.

- `View` 는 단순히 `View Model`에서 로직을 통해 변화되는 값(일단 값이라고 하자)을 `Xaml` 파일에서의 `바인딩(binding)`을 통해 투영시켜준다. => `View`와 `Xaml` 파일에서 `View Model`과 바인딩을 통해 얻은 값을 가지는 것은 아니지만 화면에 볼 수 있게 해준다. = `Xaml`은 중간다리의 역할을 해준다. 

----- 팀장님 설명 --------

모델 : 사용자한테 보여주고자하는 정보(서버에 저장되는 정보라고 이해해도 될것 같다.)

장점: MVC의 경우 모델의 데이터가 변경되면 뷰에 변경된 값을 반영하려면 controller가 반드시 일을 해야함(업데이트를 해줘야함)

MVVM의 경우 바인딩을 통해 Control에 해당하는 뷰모델이 특정한 일을 하지 않아도 model의 값이 변경이 되었을때 자동적으로 view를 업데이트

=> 가장 큰 특징 : 바인딩만 잘해줘도 화면 업데이트를 신경쓰지 않아도 됨.

단점 : 서로 다른 view간에 데이터를 주고 받을때 어려움 => MVVM

DevExpress => GetValue(), SetValue() 

Observable Collection

하나의 뷰모델에 여러개의 뷰가 있을 수 있지만 하나의 뷰에 여러개의 뷰모델은 붙을 수 없다. 만일 뷰간에 어떤 데이터를 공유해야한다면 뷰모델간 모델을 교환하거나 여러개의 뷰에 하나의 뷰모델을 이용해 업데이트 해줄 수 있다. 단 이렇게 여러개의 뷰에 하나의 뷰모델을 사용하게되면 뷰모델의 크기가 커지게 된다는 단점이 있다.

---- 대호님 설명 --- 

- 뷰에 있어서 Behavior부분에 presentation logic(뷰 로직)을 작성하고, 모델에 대한 경우는 뷰모델에서 처리한다.
- 결과적으로 뷰와 뷰모델의 바인딩을 통해 돌아갈 수 있도록 구현하는 디자인 패턴인 것 같다.